import {
	type ReAuthEngine,
	type AuthOutput,
	Entity,
	AuthToken,
	AuthInput,
	type AuthPlugin,
	type AuthStep,
} from "@re-auth/reauth";

/**
 * Context extraction rule for specific plugin/step combinations
 */
export interface ContextExtractionRule {
	pluginName: string;
	stepName?: string; // If not specified, applies to all steps in plugin
	/**
	 * Cookie names to extract from request and add to step inputs
	 */
	extractCookies?: string[];
	/**
	 * Header names to extract from request and add to step inputs
	 * Format: { headerName: inputName } or just headerName (uses same name)
	 */
	extractHeaders?: string[] | Record<string, string>;
	/**
	 * Cookie names to set in response (will be populated from step outputs)
	 */
	setCookies?: string[];
	/**
	 * Header names to set in response (will be populated from step outputs)
	 */
	setHeaders?: string[] | Record<string, string>;
	/**
	 * Transform function for input values
	 */
	transformInput?: (key: string, value: any, request: any) => any;
	/**
	 * Transform function for output values
	 */
	transformOutput?: (
		key: string,
		value: any,
		result: AuthOutput,
		request: any,
	) => any;
}

/**
 * Auto-generated route information
 */
export interface AutoGeneratedRoute {
	pluginName: string;
	stepName: string;
	method: string;
	path: string;
	requiresAuth: boolean;
	description: string;
	inputs: string[];
}

/**
 * Auto-introspection configuration
 */
export interface AutoIntrospectionConfig {
	/**
	 * Whether to enable auto-introspection (default: true)
	 */
	enabled?: boolean;
	/**
	 * Plugins to include (if not specified, all plugins are included)
	 */
	includePlugins?: string[];
	/**
	 * Plugins to exclude
	 */
	excludePlugins?: string[];
	/**
	 * Steps to exclude (format: 'pluginName.stepName')
	 */
	excludeSteps?: string[];
	/**
	 * Custom path generator for auto-generated routes
	 */
	pathGenerator?: (
		pluginName: string,
		stepName: string,
		basePath: string,
	) => string;
	/**
	 * Callback when routes are auto-generated
	 */
	onRoutesGenerated?: (routes: AutoGeneratedRoute[]) => void;
}

/**
 * Base HTTP configuration for all adapters
 */
export interface BaseHttpConfig {
	basePath?: string;
	cookieName?: string;
	cookieOptions?: {
		httpOnly?: boolean;
		secure?: boolean;
		sameSite?: "strict" | "lax" | "none" | boolean;
		maxAge?: number;
		domain?: string;
		path?: string;
	};
	/**
	 * Auto-introspection configuration
	 */
	autoIntrospection?: AutoIntrospectionConfig;
	/**
	 * Context extraction rules for plugins and steps
	 * Defines what cookies/headers to extract from requests and set in responses
	 */
	contextRules?: ContextExtractionRule[];
	/**
	 * Custom route overrides
	 * Allows overriding specific plugin step routes
	 */
	routeOverrides?: RouteOverride[];
	/**
	 * Custom routes for external plugins or additional functionality
	 */
	customRoutes?: CustomRoute[];
	/**
	 * Global middleware to apply to all routes
	 */
	globalMiddleware?: any[];
	/**
	 * Custom error handler
	 */
	errorHandler?: (error: Error, context: any) => any;
}

/**
 * Route override configuration
 */
export interface RouteOverride {
	pluginName: string;
	stepName: string;
	/**
	 * Override the HTTP method
	 */
	method?: string;
	/**
	 * Override the route path
	 */
	path?: string;
	/**
	 * Override the route handler completely
	 */
	handler?: any;
	/**
	 * Add middleware before the default handler
	 */
	middleware?: any[];
	/**
	 * Custom input extraction logic
	 */
	extractInputs?: (
		request: any,
		pluginName: string,
		stepName: string,
	) => Promise<Record<string, any>>;
	/**
	 * Custom response handling logic
	 */
	handleResponse?: (
		request: any,
		response: any,
		result: AuthOutput,
		httpConfig: any,
	) => any;
}

/**
 * Custom route configuration
 */
export interface CustomRoute {
	method: "GET" | "POST" | "PUT" | "DELETE" | "PATCH";
	path: string;
	handler: any;
	middleware?: any[];
	/**
	 * Whether this route requires authentication
	 */
	requireAuth?: boolean;
}

/**
 * HTTP adapter context for handlers
 */
export interface HttpAdapterContext {
	engine: ReAuthEngine;
	config: Required<Omit<BaseHttpConfig, "errorHandler">> & {
		errorHandler?: (error: Error, context: any) => any;
	};
	extractToken: (request: any) => string | null;
	requireAuth: () => any;
	handleStepResponse: (
		request: any,
		response: any,
		result: AuthOutput,
		httpConfig: any,
	) => any;
	errorResponse: (response: any, error: Error) => any;
	autoGeneratedRoutes: AutoGeneratedRoute[];
}

/**
 * HTTP adapter factory function type
 */
export type HttpAdapterFactory<T extends BaseHttpConfig, R = any> = (
	engine: ReAuthEngine,
	config: T,
) => R;

/**
 * Framework-specific adapter implementation
 */
export interface FrameworkAdapter<T extends BaseHttpConfig> {
	setupMiddleware(context: HttpAdapterContext): void;
	createRoute(
		method: string,
		path: string,
		handler: any,
		middleware?: any[],
	): void;
	extractInputs(
		request: any,
		pluginName: string,
		stepName: string,
	): Promise<Record<string, any>>;
	handleStepResponse(
		request: any,
		response: any,
		result: AuthOutput,
		httpConfig: any,
	): any;
	/**
	 * Add configurable context inputs from cookies and headers based on context rules
	 */
	addConfigurableContextInputs(
		request: any,
		inputs: Record<string, any>,
		pluginName: string,
		stepName: string,
		contextRules: ContextExtractionRule[],
	): void;
	/**
	 * Handle configurable context outputs (set cookies and headers) based on context rules
	 */
	handleConfigurableContextOutputs(
		request: any,
		response: any,
		result: AuthOutput,
		pluginName: string,
		stepName: string,
		contextRules: ContextExtractionRule[],
	): void;
	extractToken(request: any): string | null;
	requireAuth(): any;
	errorResponse(response: any, error: Error): any;
	getAdapter(): any;
}

/**
 * Introspect ReAuth engine and extract all available routes
 */
export function introspectReAuthEngine(
	engine: ReAuthEngine,
	config: AutoIntrospectionConfig = {},
): AutoGeneratedRoute[] {
	const routes: AutoGeneratedRoute[] = [];
	const plugins = engine.getAllPlugins();

	const {
		includePlugins,
		excludePlugins = [],
		excludeSteps = [],
		pathGenerator = defaultPathGenerator,
	} = config;

	for (const plugin of plugins) {
		// Check if plugin should be included
		if (includePlugins && !includePlugins.includes(plugin.name)) {
			continue;
		}

		// Check if plugin should be excluded
		if (excludePlugins.includes(plugin.name)) {
			continue;
		}

		for (const step of plugin.steps) {
			// Only include steps with HTTP protocol
			if (!step.protocol?.http) continue;

			const stepKey = `${plugin.name}.${step.name}`;

			// Check if step should be excluded
			if (excludeSteps.includes(stepKey)) {
				continue;
			}

			const basePath = "/auth"; // This will be updated in the factory
			const autoRoute: AutoGeneratedRoute = {
				pluginName: plugin.name,
				stepName: step.name,
				method: step.protocol.http.method,
				path: pathGenerator(plugin.name, step.name, basePath),
				requiresAuth: step.protocol.http.auth || false,
				description: step.description,
				inputs: step.inputs,
			};

			routes.push(autoRoute);
		}
	}

	return routes;
}

/**
 * Default path generator for auto-generated routes
 */
function defaultPathGenerator(
	pluginName: string,
	stepName: string,
	basePath: string,
): string {
	return `${basePath}/${pluginName}/${stepName}`;
}

/**
 * Creates a generic HTTP adapter for any framework
 */
export function createHttpAdapter<T extends BaseHttpConfig>(
	frameworkAdapter: FrameworkAdapter<T>,
): HttpAdapterFactory<T> {
	return (engine: ReAuthEngine, config: T = {} as T) => {
		// Merge with defaults
		const mergedConfig: Required<Omit<BaseHttpConfig, "errorHandler">> & {
			errorHandler?: (error: Error, context: any) => any;
		} = {
			basePath: "/auth",
			cookieName: "auth_token",
			cookieOptions: {},
			autoIntrospection: { enabled: true },
			contextRules: [],
			routeOverrides: [],
			customRoutes: [],
			globalMiddleware: [],
			...config,
		};

		// Validate required environment variables for introspection
		const requiredAuthKey = process.env.REAUTH_INTROSPECTION_KEY;
		if (!requiredAuthKey) {
			console.warn(
				"REAUTH_INTROSPECTION_KEY environment variable not set. Introspection endpoint will be disabled.",
			);
		}

		// Auto-introspect the engine
		const autoGeneratedRoutes = mergedConfig.autoIntrospection.enabled
			? introspectReAuthEngine(engine, {
					...mergedConfig.autoIntrospection,
					pathGenerator:
						mergedConfig.autoIntrospection.pathGenerator ||
						defaultPathGenerator,
				})
			: [];

		// Create adapter context
		const context: HttpAdapterContext = {
			engine,
			config: mergedConfig,
			extractToken: frameworkAdapter.extractToken.bind(frameworkAdapter),
			requireAuth: frameworkAdapter.requireAuth.bind(frameworkAdapter),
			handleStepResponse:
				frameworkAdapter.handleStepResponse.bind(frameworkAdapter),
			errorResponse: frameworkAdapter.errorResponse.bind(frameworkAdapter),
			autoGeneratedRoutes,
		};

		// Setup middleware
		frameworkAdapter.setupMiddleware(context);

		// Setup introspection endpoint first (before other routes)
		if (requiredAuthKey) {
			setupIntrospectionEndpoint(
				engine,
				frameworkAdapter,
				context,
				requiredAuthKey,
			);
		}

		// Setup auto-generated routes
		if (mergedConfig.autoIntrospection.enabled) {
			setupAutoGeneratedRoutes(engine, frameworkAdapter, context);
		}

		// Setup custom routes
		setupCustomRoutes(frameworkAdapter, context);

		return frameworkAdapter.getAdapter();
	};
}

/**
 * Setup the introspection endpoint for SDK generation
 */
function setupIntrospectionEndpoint<T extends BaseHttpConfig>(
	engine: ReAuthEngine,
	frameworkAdapter: FrameworkAdapter<T>,
	context: HttpAdapterContext,
	requiredAuthKey: string,
): void {
	const introspectionHandler = async (request: any, response: any) => {
		try {
			// Validate auth key
			const authKey =
				request.headers["x-auth-key"] || request.headers["x-reauth-key"];

			if (!authKey || authKey !== requiredAuthKey) {
				console.warn(
					"Introspection attempt with invalid auth key:",
					authKey ? "provided" : "missing",
				);
				return frameworkAdapter.errorResponse(
					response,
					new Error("Invalid or missing auth key"),
				);
			}

			// Get introspection data
			const introspectionData = engine.getIntrospectionData();

			// Send successful response
			if (response.json) {
				// Express-like response
				response.status(200).json(introspectionData);
			} else if (response.send) {
				// Fastify-like response
				response.status(200).send(introspectionData);
			} else {
				// Hono/Web framework-like response - return Response object
				return new Response(JSON.stringify(introspectionData), {
					status: 200,
					headers: { "Content-Type": "application/json" },
				});
			}
		} catch (error) {
			console.error("Introspection endpoint error:", error);
			return frameworkAdapter.errorResponse(response, error as Error);
		}
	};

	// Create the introspection route
	const introspectionPath = `${context.config.basePath}/introspect`;
	frameworkAdapter.createRoute(
		"GET",
		introspectionPath,
		introspectionHandler,
		[],
	);

	console.log(
		`âœ… Introspection endpoint available at: GET ${introspectionPath}`,
	);
	console.log("ðŸ”‘ Auth key required in header: x-auth-key or x-reauth-key");
}

/**
 * Find applicable context extraction rules for a plugin/step combination
 */
export function findContextRules(
	pluginName: string,
	stepName: string,
	contextRules: ContextExtractionRule[],
): ContextExtractionRule[] {
	return contextRules.filter((rule) => {
		if (rule.pluginName !== pluginName) return false;
		if (rule.stepName && rule.stepName !== stepName) return false;
		return true;
	});
}

/**
 * Setup auto-generated routes from ReAuth engine introspection
 */
function setupAutoGeneratedRoutes<T extends BaseHttpConfig>(
	engine: ReAuthEngine,
	frameworkAdapter: FrameworkAdapter<T>,
	context: HttpAdapterContext,
): void {
	for (const autoRoute of context.autoGeneratedRoutes) {
		// Check for route overrides
		const override = context.config.routeOverrides.find(
			(override) =>
				override.pluginName === autoRoute.pluginName &&
				override.stepName === autoRoute.stepName,
		);

		// Determine method, path, and handler
		const method = override?.method || autoRoute.method;
		const path = override?.path || autoRoute.path;

		let handler: any;
		if (override?.handler) {
			// Use custom handler
			handler = override.handler;
		} else {
			// Create default handler with optional override hooks
			handler = createAutoGeneratedStepHandler(
				autoRoute,
				frameworkAdapter,
				context,
				override,
			);
		}

		// Determine middleware
		const middleware = [
			...(context.config.globalMiddleware || []),
			...(override?.middleware || []),
		];

		// Add auth middleware if required
		if (autoRoute.requiresAuth && !override?.handler) {
			middleware.push(context.requireAuth());
		}

		// Create the route
		frameworkAdapter.createRoute(
			method.toUpperCase(),
			path,
			handler,
			middleware,
		);
	}
}

/**
 * Setup custom routes
 */
function setupCustomRoutes<T extends BaseHttpConfig>(
	frameworkAdapter: FrameworkAdapter<T>,
	context: HttpAdapterContext,
): void {
	for (const route of context.config.customRoutes) {
		const middleware = [
			...(context.config.globalMiddleware || []),
			...(route.middleware || []),
		];

		// Add auth middleware if required
		if (route.requireAuth) {
			middleware.push(context.requireAuth());
		}

		frameworkAdapter.createRoute(
			route.method,
			route.path,
			route.handler,
			middleware,
		);
	}
}

/**
 * Create a step handler for auto-generated routes with override support</edit>
 */
function createAutoGeneratedStepHandler<T extends BaseHttpConfig>(
	autoRoute: AutoGeneratedRoute,
	frameworkAdapter: FrameworkAdapter<T>,
	context: HttpAdapterContext,
	override?: RouteOverride,
): any {
	return async (request: any, response: any, next?: any): Promise<any> => {
		try {
			// Get the actual step definition to access its HTTP protocol configuration
			const plugin = context.engine.getPlugin(autoRoute.pluginName);
			const step = plugin?.steps.find((s) => s.name === autoRoute.stepName);
			const httpConfig = step?.protocol?.http || {};

			// Extract inputs (with override support)
			let inputs: Record<string, any>;
			if (override?.extractInputs) {
				inputs = await override.extractInputs(
					request,
					autoRoute.pluginName,
					autoRoute.stepName,
				);
			} else {
				inputs = await frameworkAdapter.extractInputs(
					request,
					autoRoute.pluginName,
					autoRoute.stepName,
				);
			}

			// Add auth context if authenticated
			if (request.user) {
				inputs.entity = request.user;
				inputs.token = request.token;
			}

			// Add configurable context inputs from cookies and headers
			frameworkAdapter.addConfigurableContextInputs(
				request,
				inputs,
				autoRoute.pluginName,
				autoRoute.stepName,
				context.config.contextRules,
			);

			// Execute the step
			const result = await context.engine.executeStep(
				autoRoute.pluginName,
				autoRoute.stepName,
				inputs,
			);

			// Handle the response (with override support)
			if (override?.handleResponse) {
				return override.handleResponse(request, response, result, httpConfig);
				// biome-ignore lint/style/noUselessElse: <explanation>
			} else {
				// Handle configurable context outputs (cookies and headers)
				frameworkAdapter.handleConfigurableContextOutputs(
					request,
					response,
					result,
					autoRoute.pluginName,
					autoRoute.stepName,
					context.config.contextRules,
				);
				return context.handleStepResponse(
					request,
					response,
					result,
					httpConfig,
				);
			}
		} catch (error: any) {
			console.error(
				`Error in ${autoRoute.pluginName}.${autoRoute.stepName}:`,
				error,
			);

			// Use custom error handler if provided
			if (context.config.errorHandler) {
				return context.config.errorHandler(error, {
					request,
					response,
					pluginName: autoRoute.pluginName,
					stepName: autoRoute.stepName,
				});
			}

			return context.errorResponse(
				{
					request,
					response,
					pluginName: autoRoute.pluginName,
					stepName: autoRoute.stepName,
				},
				error,
			);
		}
	};
}

/**
 * Utility function to create route override
 */
export function createRouteOverride(
	pluginName: string,
	stepName: string,
	override: Partial<Omit<RouteOverride, "pluginName" | "stepName">>,
): RouteOverride {
	return {
		pluginName,
		stepName,
		...override,
	};
}

/**
 * Utility function to create custom route
 */
export function createCustomRoute(
	method: "GET" | "POST" | "PUT" | "DELETE" | "PATCH",
	path: string,
	handler: any,
	options: {
		middleware?: any[];
		requireAuth?: boolean;
	} = {},
): CustomRoute {
	return {
		method,
		path,
		handler,
		middleware: options.middleware || [],
		requireAuth: options.requireAuth || false,
	};
}

/**
 * Utility function to create auto-introspection config
 */
export function createAutoIntrospectionConfig(
	options: Partial<AutoIntrospectionConfig> = {},
): AutoIntrospectionConfig {
	return {
		enabled: true,
		...options,
	};
}

/**
 * Utility function to create context extraction rule
 */
export function createContextRule(
	pluginName: string,
	options: Partial<Omit<ContextExtractionRule, "pluginName">> = {},
): ContextExtractionRule {
	return {
		pluginName,
		...options,
	};
}

/**
 * Predefined context rules for common OAuth scenarios
 */
export const OAuth2ContextRules = {
	/**
	 * OAuth 2.0 with PKCE context rule for extracting state and code verifier
	 */
	pkce: (pluginName: string): ContextExtractionRule =>
		createContextRule(pluginName, {
			extractCookies: ["oauth_state", "oauth_code_verifier"],
			setCookies: ["oauth_state", "oauth_code_verifier"],
		}),

	/**
	 * OAuth 2.0 regular flow context rule for extracting state
	 */
	regular: (pluginName: string): ContextExtractionRule =>
		createContextRule(pluginName, {
			extractCookies: ["oauth_state"],
			setCookies: ["oauth_state"],
		}),

	/**
	 * OAuth callback context rule for all OAuth steps
	 */
	callback: (pluginName: string): ContextExtractionRule =>
		createContextRule(pluginName, {
			stepName: "callback",
			extractCookies: ["oauth_state", "oauth_code_verifier"],
		}),

	/**
	 * OAuth start context rule for setting state and code verifier
	 */
	start: (pluginName: string): ContextExtractionRule =>
		createContextRule(pluginName, {
			stepName: "start",
			setCookies: ["oauth_state", "oauth_code_verifier"],
		}),
};
