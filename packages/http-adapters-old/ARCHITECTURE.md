# HTTP Adapter System Architecture

This document explains how the HTTP adapter system works, including all the functions, their relationships, and how to create new adapters.

## 🏗️ **System Overview**

The HTTP adapter system is designed to automatically discover ReAuth plugins and create HTTP routes for them. It supports:

- **Auto-introspection**: Automatically discovers plugins and their HTTP steps
- **Configurable context extraction**: Extract/set cookies and headers based on rules
- **Route overriding**: Override any auto-generated route with custom logic
- **Custom routes**: Add additional routes alongside auto-generated ones
- **Framework agnostic**: Works with Express, Fastify, Hono, and future frameworks

## 📊 **Flow Diagram**

```mermaid
graph TD
    A[User calls createExpressAdapter] --> B[createHttpAdapter factory]
    B --> C[ExpressFrameworkAdapter instance]

    B --> D[introspectReAuthEngine]
    D --> E[defaultPathGenerator]
    E --> F[AutoGeneratedRoute[]]

    B --> G[setupAutoGeneratedRoutes]
    G --> H[createAutoGeneratedStepHandler]
    H --> I[addConfigurableContextInputs]
    H --> J[handleConfigurableContextOutputs]

    B --> K[setupCustomRoutes]

    G --> L[findContextRules]
    I --> L
    J --> L

    M[User Config] --> N[createAutoIntrospectionConfig]
    M --> O[createRouteOverride]
    M --> P[createCustomRoute]
    M --> Q[OAuth2ContextRules]

    N --> B
    O --> B
    P --> B
    Q --> B

    C --> R[ExpressFrameworkAdapter.setupMiddleware]
    C --> S[ExpressFrameworkAdapter.createRoute]
    C --> T[ExpressFrameworkAdapter.extractInputs]
    C --> U[ExpressFrameworkAdapter.handleStepResponse]

    T --> I
    U --> J
```

## 🔧 **Function Usage Map**

### 1. **Entry Point Functions**

#### `createExpressAdapter()`

**Location**: Called by user  
**Purpose**: Entry point that creates an Express adapter instance

```typescript
// User calls this
const adapter = createExpressAdapter(reAuth, {
  autoIntrospection: createAutoIntrospectionConfig({...}),
  contextRules: [OAuth2ContextRules.pkce('google-oauth')],
  routeOverrides: [createRouteOverride(...)],
  customRoutes: [createCustomRoute(...)],
});
```

#### `createHttpAdapter()`

**Location**: `utils/http-adapter-factory.ts`  
**Purpose**: Generic factory that creates adapters for any framework

```typescript
// Called internally by createExpressAdapter
export const createExpressAdapter = createHttpAdapter(new ExpressFrameworkAdapter());
```

**What it does:**

1. Merges user config with defaults
2. Auto-introspects the ReAuth engine
3. Sets up auto-generated routes
4. Sets up custom routes
5. Returns framework-specific adapter

### 2. **Auto-Introspection Functions**

#### `introspectReAuthEngine()`

**Location**: `utils/http-adapter-factory.ts`  
**Purpose**: Discovers all plugins and their HTTP steps

```typescript
// Called inside createHttpAdapter
const autoGeneratedRoutes = mergedConfig.autoIntrospection.enabled
  ? introspectReAuthEngine(engine, {
      ...mergedConfig.autoIntrospection,
      pathGenerator: mergedConfig.autoIntrospection.pathGenerator || defaultPathGenerator,
    })
  : [];
```

**What it does:**

1. Gets all plugins from ReAuth engine
2. Filters by includePlugins/excludePlugins
3. Finds HTTP steps in each plugin
4. Excludes specific steps if configured
5. Generates paths using pathGenerator
6. Returns array of AutoGeneratedRoute objects

#### `defaultPathGenerator()`

**Location**: `utils/http-adapter-factory.ts`  
**Purpose**: Creates default paths for auto-generated routes

```typescript
// Used as fallback in introspectReAuthEngine
function defaultPathGenerator(pluginName: string, stepName: string, basePath: string): string {
  return `${basePath}/${pluginName}/${stepName}`;
}

// Results in paths like: /auth/email-password/login, /auth/google-oauth/callback
```

### 3. **Route Setup Functions**

#### `setupAutoGeneratedRoutes()`

**Location**: `utils/http-adapter-factory.ts`  
**Purpose**: Creates routes for all discovered plugin steps

```typescript
// Called inside createHttpAdapter
if (mergedConfig.autoIntrospection.enabled) {
  setupAutoGeneratedRoutes(engine, frameworkAdapter, context);
}
```

**What it does:**

1. Iterates through auto-generated routes
2. Checks for route overrides
3. Determines method, path, and handler
4. Creates handler with `createAutoGeneratedStepHandler`
5. Adds global and override middleware
6. Adds auth middleware if required
7. Calls `frameworkAdapter.createRoute`

#### `setupCustomRoutes()`

**Location**: `utils/http-adapter-factory.ts`  
**Purpose**: Creates user-defined custom routes

```typescript
// Called inside createHttpAdapter
setupCustomRoutes(frameworkAdapter, context);
```

**What it does:**

1. Iterates through custom routes
2. Adds global middleware
3. Adds auth middleware if `requireAuth: true`
4. Calls `frameworkAdapter.createRoute`

#### `createAutoGeneratedStepHandler()`

**Location**: `utils/http-adapter-factory.ts`  
**Purpose**: Creates handlers for auto-generated plugin routes

```typescript
// Called inside setupAutoGeneratedRoutes
handler = createAutoGeneratedStepHandler(autoRoute, frameworkAdapter, context, override);
```

**What it does:**

1. Creates async handler function
2. Extracts inputs using `frameworkAdapter.extractInputs`
3. Adds auth context if authenticated
4. Calls `addConfigurableContextInputs`
5. Executes ReAuth step with `engine.executeStep`
6. Handles response with override or default logic
7. Calls `handleConfigurableContextOutputs`
8. Handles errors with custom error handler

### 4. **Context Processing Functions**

#### `findContextRules()`

**Location**: `utils/http-adapter-factory.ts`  
**Purpose**: Finds applicable context rules for plugin/step combinations

```typescript
// Called inside addConfigurableContextInputs and handleConfigurableContextOutputs
const applicableRules = findContextRules(pluginName, stepName, contextRules);
```

**What it does:**

1. Filters context rules by plugin name
2. Filters by step name (if specified in rule)
3. Returns matching rules for current plugin/step

#### `addConfigurableContextInputs()`

**Location**: `utils/http-adapter-factory.ts` + Express adapter  
**Purpose**: Extracts cookies/headers based on context rules

```typescript
// Called inside createAutoGeneratedStepHandler
addConfigurableContextInputs(request, inputs, autoRoute.pluginName, autoRoute.stepName, context.config.contextRules);

// Also called in Express adapter's extractInputs method
if (request.__contextRules) {
  this.addConfigurableContextInputs(request, inputs, pluginName, stepName, request.__contextRules);
}
```

**What it does:**

1. Finds applicable context rules using `findContextRules`
2. Extracts cookies specified in `extractCookies`
3. Extracts headers specified in `extractHeaders`
4. Applies `transformInput` functions if provided
5. Adds extracted values to step inputs

#### `handleConfigurableContextOutputs()`

**Location**: `utils/http-adapter-factory.ts` + Express adapter  
**Purpose**: Sets cookies/headers based on context rules and step results

```typescript
// Called inside createAutoGeneratedStepHandler
handleConfigurableContextOutputs(request, response, result, autoRoute.pluginName, autoRoute.stepName, context.config.contextRules);

// Also called in Express adapter's handleStepResponse method
if (request.__contextRules && request.__pluginName && request.__stepName) {
  this.handleConfigurableContextOutputs(request, response, result, request.__pluginName, request.__stepName, request.__contextRules);
}
```

**What it does:**

1. Finds applicable context rules using `findContextRules`
2. Sets cookies from step result based on `setCookies`
3. Sets headers from step result based on `setHeaders`
4. Applies `transformOutput` functions if provided
5. Handles complex cookie options (httpOnly, secure, etc.)

### 5. **Configuration Helper Functions**

#### `createAutoIntrospectionConfig()`

**Location**: `utils/http-adapter-factory.ts`  
**Purpose**: Creates auto-introspection configuration with defaults

```typescript
// Used by user in adapter config
autoIntrospection: createAutoIntrospectionConfig({
  enabled: true,
  includePlugins: ['email-password', 'google-oauth'],
  pathGenerator: (pluginName, stepName, basePath) => `${basePath}/v1/${pluginName}/${stepName}`,
  onRoutesGenerated: (routes) => console.log(`Generated ${routes.length} routes`),
});
```

#### `createRouteOverride()`

**Location**: `utils/http-adapter-factory.ts`  
**Purpose**: Creates route override configurations

```typescript
// Used by user in adapter config
routeOverrides: [
  createRouteOverride('email-password', 'login', {
    path: '/custom-login',
    method: 'POST',
    middleware: [rateLimitMiddleware],
    extractInputs: customInputExtractor,
    handleResponse: customResponseHandler,
  }),
];
```

#### `createCustomRoute()`

**Location**: `utils/http-adapter-factory.ts`  
**Purpose**: Creates custom route configurations

```typescript
// Used by user in adapter config
customRoutes: [
  createCustomRoute('GET', '/health', healthHandler),
  createCustomRoute('POST', '/logout', logoutHandler, { requireAuth: true }),
  createCustomRoute('GET', '/admin/users', adminHandler, {
    requireAuth: true,
    middleware: [adminOnly],
  }),
];
```

#### `OAuth2ContextRules`

**Location**: `utils/http-adapter-factory.ts`  
**Purpose**: Predefined context rules for common OAuth scenarios

```typescript
// Used by user in adapter config
contextRules: [
  OAuth2ContextRules.pkce('google-oauth'), // PKCE flow with state & code_verifier
  OAuth2ContextRules.regular('github-oauth'), // Regular OAuth with state only
  OAuth2ContextRules.callback('facebook-oauth'), // Callback-specific extraction
  OAuth2ContextRules.start('linkedin-oauth'), // Start-specific cookie setting
];
```

**Available rules:**

- `OAuth2ContextRules.pkce(pluginName)`: Extracts and sets `oauth_state` and `oauth_code_verifier`
- `OAuth2ContextRules.regular(pluginName)`: Extracts and sets `oauth_state` only
- `OAuth2ContextRules.callback(pluginName)`: Callback step specific extraction
- `OAuth2ContextRules.start(pluginName)`: Start step specific cookie setting

### 6. **Express Framework Adapter Implementation**

#### `ExpressFrameworkAdapter`

**Location**: `adapters/express/express-adapter-.ts`  
**Purpose**: Express-specific implementation of `FrameworkAdapter<ExpressAdapterConfig>`

```typescript
class ExpressFrameworkAdapter implements FrameworkAdapter<ExpressAdapterConfig> {
  setupMiddleware(context: HttpAdapterContext): void;
  createRoute(method: string, path: string, handler: any, middleware: any[]): void;
  extractInputs(request: any, pluginName: string, stepName: string): Promise<Record<string, any>>;
  handleStepResponse(request: any, response: Response, result: AuthOutput, httpConfig: any): void;
  extractToken(request: Request): string | null;
  requireAuth(): any;
  errorResponse(response: Response, error: Error): void;
  getAdapter(): Router;
}
```

**Key methods:**

##### `setupMiddleware()`

1. Parses cookies if not already parsed
2. Applies global middleware from config
3. Attaches context rules to requests (`req.__contextRules`)
4. Sets up authentication middleware
5. Attaches session data to `req.user` and `req.token`

##### `createRoute()`

1. Wraps handler to attach plugin/step context
2. Extracts plugin and step names from route path
3. Attaches to `req.__pluginName` and `req.__stepName`
4. Creates Express route with middleware

##### `extractInputs()`

1. Extracts expected inputs from body/query/params
2. Calls `addConfigurableContextInputs` for context extraction
3. Returns combined inputs object

##### `handleStepResponse()`

1. Handles auth token cookie setting
2. Handles additional cookies from `result.cookies`
3. Calls `handleConfigurableContextOutputs` for context handling
4. Handles redirects
5. Sends JSON response with appropriate status code

## 🚀 **Complete Flow Example**

```typescript
// 1. User creates adapter
const adapter = createExpressAdapter(reAuth, {
  basePath: '/api/auth',
  autoIntrospection: createAutoIntrospectionConfig({
    pathGenerator: (plugin, step, base) => `${base}/v1/${plugin}/${step}`,
    includePlugins: ['email-password', 'google-oauth'],
    excludeSteps: ['email-password.verify-email'],
  }),
  contextRules: [
    OAuth2ContextRules.pkce('google-oauth'),
    createContextRule('email-password', {
      stepName: 'login',
      extractHeaders: { 'x-forwarded-for': 'client_ip' },
      extractCookies: ['login_attempts'],
      setCookies: ['last_login'],
    }),
  ],
  routeOverrides: [
    createRouteOverride('email-password', 'login', {
      path: '/signin',
      middleware: [rateLimitMiddleware],
    }),
  ],
  customRoutes: [createCustomRoute('GET', '/health', healthHandler), createCustomRoute('GET', '/me', profileHandler, { requireAuth: true })],
});

// 2. createHttpAdapter is called with ExpressFrameworkAdapter
// 3. introspectReAuthEngine discovers:
//    - email-password: login, register, forgot-password (verify-email excluded)
//    - google-oauth: start, callback, link, unlink

// 4. Auto-generated routes created:
//    POST /api/auth/v1/email-password/register -> createAutoGeneratedStepHandler
//    POST /api/auth/v1/email-password/forgot-password -> createAutoGeneratedStepHandler
//    GET  /api/auth/v1/google-oauth/start -> createAutoGeneratedStepHandler
//    POST /api/auth/v1/google-oauth/callback -> createAutoGeneratedStepHandler
//    POST /api/auth/v1/google-oauth/link -> createAutoGeneratedStepHandler (auth required)
//    POST /api/auth/v1/google-oauth/unlink -> createAutoGeneratedStepHandler (auth required)

// 5. Route overrides applied:
//    POST /signin (instead of /api/auth/v1/email-password/login)

// 6. Custom routes added:
//    GET /health -> healthHandler
//    GET /me -> profileHandler (auth required)

// 7. When POST /signin is called:
//    - ExpressFrameworkAdapter.extractInputs extracts email/password from body
//    - addConfigurableContextInputs extracts client_ip from x-forwarded-for header
//    - addConfigurableContextInputs extracts login_attempts from cookie
//    - ReAuth executes email-password.login step with all inputs
//    - ExpressFrameworkAdapter.handleStepResponse sets auth cookie
//    - handleConfigurableContextOutputs sets last_login cookie if login successful

// 8. When GET /api/auth/v1/google-oauth/start is called:
//    - createAutoGeneratedStepHandler processes request
//    - ReAuth executes google-oauth.start step
//    - OAuth2ContextRules.pkce sets oauth_state and oauth_code_verifier cookies
//    - Response redirects to Google OAuth URL

// 9. When POST /api/auth/v1/google-oauth/callback is called:
//    - addConfigurableContextInputs extracts oauth_state and oauth_code_verifier from cookies
//    - ReAuth executes google-oauth.callback with OAuth context
//    - Response handles OAuth success/failure appropriately
```

## 🛠️ **Creating a New Adapter**

To create a new adapter for a different framework (e.g., Fastify, Hono, Koa), you need to:

### 1. **Implement `FrameworkAdapter<T>` interface**

```typescript
// Define framework-specific config
interface MyFrameworkConfig extends BaseHttpConfig {
  // Add framework-specific options here
  myFrameworkOption?: boolean;
}

// Implement the framework adapter
class MyFrameworkAdapter implements FrameworkAdapter<MyFrameworkConfig> {
  private app: MyFrameworkApp;

  constructor() {
    this.app = new MyFrameworkApp();
  }

  setupMiddleware(context: HttpAdapterContext): void {
    // 1. Parse cookies (framework-specific)
    this.app.use(cookieParser());

    // 2. Apply global middleware
    if (context.config.globalMiddleware) {
      context.config.globalMiddleware.forEach((middleware) => {
        this.app.use(middleware);
      });
    }

    // 3. Attach context rules to requests
    this.app.use((req, res, next) => {
      req.__contextRules = context.config.contextRules;
      next();
    });

    // 4. Setup auth middleware (framework-specific)
    this.app.use(async (req, res, next) => {
      const token = this.extractToken(req);
      if (token) {
        try {
          const session = await context.engine.checkSession(token);
          if (session.valid && session.entity) {
            req.user = session.entity;
            req.token = session.token;
            req.isAuthenticated = () => true;
          }
        } catch (error) {
          console.warn('Invalid token:', error);
        }
      }
      if (!req.isAuthenticated) {
        req.isAuthenticated = () => false;
      }
      next();
    });
  }

  createRoute(method: string, path: string, handler: any, middleware: any[] = []): void {
    // Framework-specific route creation
    const wrappedHandler = (req, res, next) => {
      // Extract plugin/step from path for context
      const pathMatch = path.match(/\/([^\/]+)\/([^\/]+)$/);
      if (pathMatch) {
        req.__pluginName = pathMatch[1];
        req.__stepName = pathMatch[2];
      }
      return handler(req, res, next);
    };

    // Create route with framework-specific syntax
    this.app[method.toLowerCase()](path, ...middleware, wrappedHandler);
  }

  async extractInputs(request: any, pluginName: string, stepName: string): Promise<Record<string, any>> {
    // 1. Extract expected inputs from request (framework-specific)
    const expectedInputs = request.__engine?.getStepInputs?.(pluginName, stepName) || [];
    const inputs: Record<string, any> = {};

    expectedInputs.forEach((inputName: string) => {
      // Framework-specific input extraction
      if (request.body?.[inputName] !== undefined) {
        inputs[inputName] = request.body[inputName];
      } else if (request.query?.[inputName] !== undefined) {
        inputs[inputName] = request.query[inputName];
      }
    });

    // 2. Add configurable context inputs
    if (request.__contextRules) {
      this.addConfigurableContextInputs(request, inputs, pluginName, stepName, request.__contextRules);
    }

    return inputs;
  }

  handleStepResponse(request: any, response: any, result: AuthOutput, httpConfig: any): void {
    const { token, redirect, success, status, cookies, ...data } = result;

    // 1. Handle auth token (framework-specific)
    if (token) {
      const config = request.__adapterConfig;
      response.cookie(config.cookieName, token, config.cookieOptions);
    }

    // 2. Handle additional cookies
    if (cookies) {
      Object.entries(cookies).forEach(([name, value]) => {
        response.cookie(name, value as string);
      });
    }

    // 3. Handle configurable context outputs
    if (request.__contextRules && request.__pluginName && request.__stepName) {
      this.handleConfigurableContextOutputs(request, response, result, request.__pluginName, request.__stepName, request.__contextRules);
    }

    // 4. Handle redirect (framework-specific)
    if (redirect) {
      return response.redirect(redirect);
    }

    // 5. Send response (framework-specific)
    const statusCode = this.getStatusCode(result, httpConfig);
    response.status(statusCode).json({ success, ...data });
  }

  extractToken(request: any): string | null {
    // Framework-specific token extraction
    // Check cookies, headers, etc.
    return request.cookies?.auth_token || request.headers.authorization?.replace('Bearer ', '') || null;
  }

  requireAuth(): any {
    // Framework-specific auth middleware
    return (req, res, next) => {
      if (!req.isAuthenticated?.()) {
        return res.status(401).json({ error: 'Authentication required' });
      }
      next();
    };
  }

  errorResponse(response: any, error: Error): void {
    // Framework-specific error response
    console.error('HTTP Adapter Error:', error);
    response.status(500).json({
      success: false,
      message: error.message || 'Internal server error',
    });
  }

  getAdapter(): MyFrameworkApp {
    return this.app;
  }

  // Helper methods (same as Express adapter)
  private addConfigurableContextInputs(/* ... */) {
    /* Same logic as factory */
  }
  private handleConfigurableContextOutputs(/* ... */) {
    /* Same logic as factory */
  }
  private getStatusCode(/* ... */) {
    /* Same logic as Express */
  }
}
```

### 2. **Create factory function**

```typescript
// Create the adapter factory
export const createMyFrameworkAdapter = createHttpAdapter(new MyFrameworkAdapter());

// Create convenience wrapper
export function createMyFrameworkAdapter(engine: ReAuthEngine, config: MyFrameworkConfig = {}): MyFrameworkApp {
  return createMyFrameworkAdapter(engine, config);
}
```

### 3. **Export utilities**

```typescript
// Export everything users need
export { createMyFrameworkAdapter, createMyFrameworkAdapter, createRouteOverride, createCustomRoute, createAutoIntrospectionConfig, createContextRule, OAuth2ContextRules, type MyFrameworkConfig, type RouteOverride, type CustomRoute, type ContextExtractionRule };
```

### 4. **Usage is identical across frameworks**

```typescript
// Works exactly the same as Express!
const adapter = createMyFrameworkAdapter(reAuth, {
  autoIntrospection: createAutoIntrospectionConfig({
    pathGenerator: (plugin, step, base) => `${base}/${plugin}/${step}`,
  }),
  contextRules: [OAuth2ContextRules.pkce('google-oauth')],
  routeOverrides: [createRouteOverride('email-password', 'login', { path: '/signin' })],
  customRoutes: [createCustomRoute('GET', '/health', healthHandler)],
});
```

## 🎯 **Key Benefits of This Architecture**

1. **90% Code Reuse**: Most logic is in the factory, only framework-specific parts need implementation
2. **Consistent API**: Same configuration works across all frameworks
3. **Auto-Discovery**: Automatically finds and creates routes for all plugins
4. **Flexible Context**: Configurable cookie/header extraction and setting
5. **Override Support**: Can override any auto-generated behavior
6. **Type Safety**: Full TypeScript support with proper interfaces
7. **Extensible**: Easy to add new frameworks without changing core logic

## 📝 **Summary**

The HTTP adapter system uses a **factory pattern** where:

- **Core logic** (introspection, context rules, route setup) is framework-agnostic
- **Framework adapters** handle framework-specific details (routing, middleware, request/response handling)
- **Configuration helpers** provide easy-to-use APIs for common scenarios
- **Context system** automatically handles cookies and headers based on rules
- **Override system** allows customization of any auto-generated behavior

This design makes it easy to add support for new frameworks while maintaining consistency and reusing the vast majority of the codebase.
