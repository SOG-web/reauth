---
title: API Structure
description: Understand the TypeScript surface area exposed by the ReAuth engine, plugins, and hooks.
---

## High-Level Map

```mermaid
flowchart LR
    subgraph Engine[ReAuthEngine]
        Config[ReAuthConfig]
        Hooks[Engine Hooks]
        SessionSvc[FumaSessionService]
        Cleanup[Cleanup Scheduler]
    end

    subgraph Plugin[AuthPlugin]
        Steps[AuthStep]
        RootHooks[Root Hooks]
        Tasks[Cleanup Tasks]
    end

    subgraph Runtime[Execution]
        Before[before]
        Run[run]
        After[after]
    end

    Config --> Engine
    Engine --> Plugin
    Plugin --> Runtime
    Runtime --> SessionSvc
    Plugin --> Cleanup

    style Engine fill:#fff3e0,stroke:#ef6c00,stroke-width:3px
    style Plugin fill:#e1f5ff,stroke:#0288d1,stroke-width:2px
    style Runtime fill:#e8f5e9,stroke:#388e3c,stroke-width:2px
```

ReAuth does **not** expose a flow router. Everything runs through plugins, steps, and their associated hooks.

## Engine Configuration

`ReAuthConfig` is the only required input to construct an engine:

```ts
export type ReAuthConfig<P extends AuthPlugin[] = AuthPlugin[]> = {
  dbClient: FumaClient;
  plugins?: P;
  tokenFactory?: () => string;
  authHooks: Array<AuthHook<P>>;
  sessionHooks: Array<AuthHook<P>>;
  enableCleanupScheduler?: boolean; // Default true
  getUserData: (
    subjectId: string,
    orm: OrmLike,
  ) => Promise<Record<string, any>>;
  deviceValidator?: (
    storedDeviceInfo: Record<string, any>,
    currentDeviceInfo: Record<string, any>,
  ) => boolean | Promise<boolean>;
};
```

**Key Configuration Options:**

- `dbClient`: Must implement the FumaDB client interface (see `packages/reauth/src/types.ts`)
- `plugins`: Ordered list of authentication plugins; dependencies managed by plugin authors
- `authHooks`: Engine-level hooks for step execution (before/after/onError)
- `sessionHooks`: Session-level hooks for session lifecycle events
- `getUserData`: Function to fetch user data for JWT payloads and session hydration
- `enableCleanupScheduler`: Defaults to `true`; runs plugin cleanup tasks in background
- `tokenFactory`: Optional custom token generation function
- `deviceValidator`: Optional device validation for enhanced session security

### Engine Entry Points

`ReAuthEngine` exposes these key methods:

**Core Execution:**

- `executeStep(pluginName, stepName, input)` – Main step executor with validation and hook orchestration
- `runStep(...)` – Alias that returns `AuthOutput` for backward compatibility

**Session Management:**

- `createSessionFor(subjectType, subjectId, ttl?, deviceInfo?)` – Create sessions without touching the service directly
- `checkSession(token, deviceInfo?)` – Verify access tokens and hydrate subjects

**Runtime Registration:**

- `registerAuthHook(hook)` – Add engine-level hooks at runtime
- `registerSessionHook(hook)` – Extend session lifecycle behavior
- `registerSessionResolver(subjectType, resolver)` – Teach session service how to hydrate custom subjects
- `registerCleanupTask(task)` – Register plugin maintenance jobs with the scheduler

**Service Access:**

- `getService<T>('name')` – Access Awilix-registered services
- `getContainer()` – Access the Awilix dependency injection container
- `getOrm()` – Resolve a FumaDB ORM instance with the current database version

**Plugin Inspection:**

- `getAllPlugins()` – Get all registered plugins
- `getPlugin(name)` – Get a specific plugin by name

**Introspection & Metadata:**

- `getUnifiedProfile(subjectId)` – Get aggregated profile data from all plugins
- `getIntrospectionData()` – Expose runtime metadata for tooling and dashboards

## Plugin API

Plugins describe configuration, steps, and optional lifecycle hooks:

```ts
export interface AuthPlugin<Cfg = any> {
  name: string;
  config: Cfg;
  initialize?: (engine: ReAuthEngine, config: Cfg) => Promise<void> | void;
  steps?: Array<AuthStep<Cfg>>;
  rootHooks?: RootStepHooks<Cfg>;
  getSensitiveFields?: () => string[];
  getProfile?: (
    subjectId: string,
    ctx: PluginProfileContext,
  ) => Promise<any> | any;
}
```

**Plugin Interface Breakdown:**

- `name`: Unique identifier for the plugin
- `config`: Plugin-specific configuration object
- `initialize`: Optional setup function called when plugin is registered
- `steps`: Array of authentication steps provided by the plugin
- `rootHooks`: Plugin-level hooks that apply to all steps
- `getSensitiveFields`: Optional function to identify sensitive fields for introspection filtering
- `getProfile`: Optional function to provide profile data for user profiles

### Step Definition

```ts
export interface AuthStep<Cfg, I = AuthInput, O = AuthOutput> {
  name: string;
  description?: string;
  validationSchema?: Type<any>; // ArkType schema for input validation
  outputs?: Type<any>; // Optional ArkType schema for output validation
  run: (input: I, ctx: StepContext<Cfg>) => Promise<O> | O;
  hooks?: StepHooks<Cfg, I, O>;
  inputs?: string[]; // Named inputs for documentation and introspection
  protocol?: StepProtocolMeta; // HTTP metadata used by adapters
}

export interface StepContext<Cfg> {
  engine: ReAuthEngine;
  config: Cfg;
}
```

**Step Interface Breakdown:**

- `name`: Unique identifier for the step within the plugin
- `description`: Optional human-readable description
- `validationSchema`: ArkType schema for runtime input validation and TypeScript type inference
- `outputs`: Optional ArkType schema for output validation
- `run`: Main execution function that implements the step logic
- `hooks`: Step-specific hooks (before/after/onError)
- `inputs`: Array of input field names for documentation and introspection
- `protocol`: HTTP metadata (method, status codes, auth requirements) used by adapters

**Step Context:**

The `StepContext` provides access to:

- `engine`: The ReAuth engine instance for calling other steps or services
- `config`: The plugin's configuration object

Steps are **transport-agnostic**. HTTP adapters map routes to `plugin.step` pairs and use the ArkType schemas to coerce and validate payloads.

### Hook Interfaces

- **Engine hooks**:

  ```ts
  export interface AuthHook {
    type: HooksType; // 'before' | 'after' | 'onError'
    pluginName?: string;
    steps?: string[];
    session?: boolean; // rarely used, prefer registerSessionHook
    universal?: boolean;
    fn: (
      data: AuthInput | AuthOutput,
      container: ReAuthCradle,
      error?: unknown,
    ) => Promise<AuthInput | AuthOutput | void> | AuthInput | AuthOutput | void;
  }
  ```

- **Plugin root hooks** (per plugin):

  ```ts
  export interface RootStepHooks<Cfg> {
    before?: (
      input: AuthInput,
      ctx: StepContext<Cfg>,
      step: AuthStep<Cfg>,
    ) => Promise<AuthInput> | AuthInput;
    after?: (
      output: AuthOutput,
      ctx: StepContext<Cfg>,
      step: AuthStep<Cfg>,
    ) => Promise<AuthOutput> | AuthOutput;
    onError?: (
      error: unknown,
      input: AuthInput,
      ctx: StepContext<Cfg>,
      step: AuthStep<Cfg>,
    ) => Promise<void> | void;
  }
  ```

- **Step hooks** (per step):

  ```ts
  export interface StepHooks<Cfg, I = AuthInput, O = AuthOutput> {
    before?: (input: I, ctx: StepContext<Cfg>) => Promise<void> | void;
    after?: (output: O, ctx: StepContext<Cfg>) => Promise<void> | void;
    onError?: (error: unknown, ctx: StepContext<Cfg>) => Promise<void> | void;
  }
  ```

Hook ordering is deterministic: engine → plugin root → step, then reversed on the way out. Engine-level `onError` hooks receive the original input so they can inspect or mutate it before rethrowing.

## Session API

`FumaSessionService` implements the `SessionService` interface defined in `types.ts`:

```ts
export interface SessionService {
  enableEnhancedFeatures(): void;
  enableJWKS(options: {
    issuer: string;
    keyRotationIntervalDays: number;
    keyGracePeriodDays: number;
    defaultAccessTokenTtlSeconds: number;
    defaultRefreshTokenTtlSeconds: number;
    enableRefreshTokenRotation: boolean;
  }): void;
  createSession(
    subjectType: string,
    subjectId: string,
    ttlSeconds?: number,
  ): Promise<Token>;
  createSessionWithMetadata?(
    subjectType: string,
    subjectId: string,
    options: CreateSessionOptions,
  ): Promise<Token>;
  verifySession(
    token: Token,
    deviceInfo?: Record<string, any>,
  ): Promise<{
    subject: any | null;
    token: Token | null;
    type?: 'jwt' | 'legacy';
    payload?: ReAuthJWTPayload;
  }>;
  destroySession(token: Token): Promise<void>;
  destroyAllSessions(subjectType: string, subjectId: string): Promise<void>;
  listSessionsFor?(
    subjectType: string,
    subjectId: string,
  ): Promise<
    Array<{
      sessionId: string;
      token: string;
      createdAt: Date;
      expiresAt: Date | null;
      deviceInfo?: Record<string, any>;
      metadata?: Record<string, any>;
    }>
  >;
  getPublicJWKS?(): Promise<{ keys: JWK[] }>;
  getJwkService(): EnhancedJWKSService | null;
}
```

Session hooks registered through `registerSessionHook` wrap `createSessionFor` and `checkSession` rather than the underlying service. Use them for analytics, device checks, or distributed cache invalidation.

### Session Resolvers

Subject resolvers hydrate custom user types:

```ts
engine.registerSessionResolver('organizationMember', {
  async getById(id, orm) {
    return orm.table('organizationMembers').findUnique(id);
  },
  sanitize(subject) {
    return { id: subject.id, organizationId: subject.organizationId };
  },
});
```

## Cleanup Scheduler API

Plugins add background jobs using `CleanupTask`:

```ts
export interface CleanupTask {
  name: string;
  pluginName: string;
  intervalMs: number;
  enabled: boolean;
  runner: (
    orm: OrmLike,
    config?: any,
  ) => Promise<{ cleaned: number; errors?: string[] }>;
}

export interface CleanupScheduler {
  registerTask(task: CleanupTask): void;
  start(): Promise<void>;
  stop(): Promise<void>;
  isRunning(): boolean;
  getRegisteredTasks(): CleanupTask[];
  setPluginConfig(pluginName: string, config: any): void;
}
```

`SimpleCleanupScheduler` runs in-process with setInterval. Tasks receive the plugin's configuration so they can respect user-defined thresholds (e.g., invitation expiry).

## Introspection Metadata

The engine exposes two read-only helpers:

```ts
engine.getStepInputs(pluginName, stepName); // => string[]
engine.getIntrospectionData(); // => { plugins: [...], generatedAt, version }
```

`getIntrospectionData` converts ArkType schemas to JSON Schema via `toJsonSchema()` so SDK generators or admin dashboards can render structured documentation.

## Putting It Together

```ts
import createReAuthEngine from '@re-auth/reauth';

const engine = createReAuthEngine({
  dbClient,
  plugins: [emailPasswordPlugin, oauthPlugin, organizationPlugin],
  getUserData: async (subjectId, orm) => ({
    profile: await orm.table('users').findUnique(subjectId),
  }),
});

engine.registerAuthHook({
  type: 'before',
  universal: true,
  fn: async (input) => ({ ...input, requestedAt: new Date().toISOString() }),
});

await engine.executeStep('email-password', 'register', {
  email: 'alice@example.com',
  password: 'hunter2',
});
```

The engine stays transport-agnostic: adapters simply translate HTTP (or any protocol) into `executeStep` calls while benefiting from validation, hooks, and session helpers defined here.

## Next Steps

<Cards>
  <Card
    href="./engine-internals"
    title="Engine Internals"
    description="See how the engine walks through the hook pipeline"
  />
  <Card
    href="./plugin-development"
    title="Plugin Development"
    description="Author a custom plugin using AuthStep and RootStepHooks"
  />
  <Card
    href="../partial-integration"
    title="Partial Integration"
    description="Use specific plugins alongside an existing auth system"
  />
</Cards>
