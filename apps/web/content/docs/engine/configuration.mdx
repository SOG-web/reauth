---
title: Configuration
description: Detailed reference for configuring the ReAuth engine.
---

## createReAuthEngine options

| Option                   | Type           | Required | Description                                             |
| ------------------------ | -------------- | -------- | ------------------------------------------------------- |
| `dbClient`               | `FumaClient`   | Yes      | FumaDB client for database operations                   |
| `plugins`                | `AuthPlugin[]` | No       | List of plugins that register authentication flows      |
| `authHooks`              | `AuthHook[]`   | No       | Engine-level hooks that run before/after all steps      |
| `sessionHooks`           | `AuthHook[]`   | No       | Session-level hooks for session lifecycle events        |
| `getUserData`            | `Function`     | Yes      | Function to fetch user data for JWT payloads            |
| `tokenFactory`           | `Function`     | No       | Custom token generation function                        |
| `deviceValidator`        | `Function`     | No       | Custom device validation function                       |
| `enableCleanupScheduler` | `boolean`      | No       | Enable/disable background cleanup tasks (default: true) |

### Database Client

ReAuth uses FumaDB for database operations. You need to provide a `FumaClient` instance:

```ts
export interface FumaClient {
  version(): Promise<any>;
  orm(version: any): OrmLike;
}
```

ReAuth ships with FumaDB adapters for popular databases. Here's how to set it up:

```ts
import createReAuthEngine, {
  reauthDb,
  reauthDbVersions,
} from '@re-auth/reauth';
import { kyselyAdapter } from 'fumadb/adapters/kysely';
import emailPasswordPlugin, {
  emailPasswordSchema,
} from '@re-auth/reauth/plugins/email-password';

// Setup database schema and client
const { schema: v1 } = reauthDb('1.0.1', [emailPasswordSchema]);
const factory = reauthDbVersions([v1]);
const client = factory.client(
  kyselyAdapter({ provider: 'sqlite', db: kysely }),
);

const engine = createReAuthEngine({
  dbClient: {
    version: async () => await client.version(),
    orm: (version: any) => client.orm(version),
  },
  plugins: [emailPasswordPlugin({})],
  getUserData: async (subjectId, orm) => {
    const user = await orm.findFirst('subjects', {
      where: (b) => b('id', '=', subjectId),
    });
    return user ?? {};
  },
});
```

### Engine Hooks

ReAuth supports hooks at multiple levels for extending functionality:

#### Auth Hooks (Engine-level)

```ts
const engine = createReAuthEngine({
  dbClient,
  authHooks: [
    {
      type: 'before',
      universal: true, // Runs for all plugins and steps
      fn: async (input, container) => {
        console.log('Before any authentication step');
        return input;
      },
    },
    {
      type: 'after',
      universal: true,
      fn: async (output, container) => {
        console.log('After any authentication step');
        return output;
      },
    },
  ],
  getUserData: async (subjectId, orm) => ({}),
});
```

#### Session Hooks

```ts
const engine = createReAuthEngine({
  dbClient,
  sessionHooks: [
    {
      type: 'before',
      fn: async (data, container) => {
        console.log('Before session creation/verification');
        return data;
      },
    },
    {
      type: 'after',
      fn: async (data, container) => {
        console.log('After session creation/verification');
        return data;
      },
    },
  ],
  getUserData: async (subjectId, orm) => ({}),
});
```

### getUserData Function

The `getUserData` function is required and is used to fetch user data for JWT payloads and session hydration:

```ts
const engine = createReAuthEngine({
  dbClient,
  getUserData: async (subjectId, orm) => {
    // Fetch user data from your database
    const user = await orm.findFirst('subjects', {
      where: (b) => b('id', '=', subjectId),
    });

    // Return user data that will be included in JWT tokens
    return {
      id: user?.id,
      email: user?.email,
      role: user?.role,
      // ... other user properties
    };
  },
});
```

### Device Validation

Optional device validation for enhanced session security:

```ts
const engine = createReAuthEngine({
  dbClient,
  deviceValidator: async (storedDeviceInfo, currentDeviceInfo) => {
    // Compare device fingerprints, IP addresses, etc.
    const isSameDevice =
      storedDeviceInfo.userAgent === currentDeviceInfo.userAgent &&
      storedDeviceInfo.ipAddress === currentDeviceInfo.ipAddress;

    return isSameDevice;
  },
  getUserData: async (subjectId, orm) => ({}),
});
```

### Cleanup Scheduler

ReAuth includes a background cleanup scheduler that runs plugin cleanup tasks:

```ts
const engine = createReAuthEngine({
  dbClient,
  enableCleanupScheduler: true, // Default: true
  plugins: [
    emailPasswordPlugin({
      cleanupIntervalMinutes: 60, // Plugin-specific cleanup interval
    }),
  ],
  getUserData: async (subjectId, orm) => ({}),
});
```

The cleanup scheduler automatically:

- Runs plugin cleanup tasks at specified intervals
- Cleans up expired tokens, codes, and sessions
- Logs cleanup results for monitoring
- Can be disabled by setting `enableCleanupScheduler: false`

## Schema Versioning

ReAuth uses a versioned schema system to support database migrations and plugin additions over time. This is **critical** when adding new plugins to an existing ReAuth server.

### Basic Schema Setup

When starting a new project, create your initial schema version:

```ts
import createReAuthEngine, {
  reauthDb,
  reauthDbVersions,
} from '@re-auth/reauth';
import { kyselyAdapter } from 'fumadb/adapters/kysely';
import emailPasswordPlugin, {
  emailPasswordSchema,
} from '@re-auth/reauth/plugins/email-password';
import { jwtSchema } from '@re-auth/reauth/services';
import sessionPlugin, { sessionSchema } from '@re-auth/reauth/plugins/session';

// Version 1.0.1 - Initial schema with core authentication
const { schema: v1, plugins: v1Plugins } = reauthDb('1.0.1', [
  emailPasswordSchema,
  jwtSchema,
  sessionSchema,
]);

const factory = reauthDbVersions([v1]);
const client = factory.client(
  kyselyAdapter({ provider: 'sqlite', db: kysely }),
);

const engine = createReAuthEngine({
  dbClient: {
    version: async () => await client.version(),
    orm: (version) => client.orm(version),
  },
  plugins: [
    sessionPlugin({}),
    emailPasswordPlugin({
      /* config */
    }),
  ],
  getUserData: async (subjectId, orm) => ({ id: subjectId }),
});
```

### Adding New Plugins with Schema Versions

When you need to add new plugins to an **existing** ReAuth server, use `extendSchemaVersion` to create a new version:

```ts
import { extendSchemaVersion } from '@re-auth/reauth';
import { usernamePasswordSchema } from '@re-auth/reauth/plugins/username';
import { anonymousSchema } from '@re-auth/reauth/plugins/anonymous';
import { phonePasswordSchema } from '@re-auth/reauth/plugins/phone';

// Version 1.0.1 - Base schema (existing)
const { schema: v1, plugins: v1Plugins } = reauthDb('1.0.1', [
  emailPasswordSchema,
  jwtSchema,
  sessionSchema,
]);

// Version 1.0.2 - Extend v1 with new plugins
const { schema: v2, plugins: v2Plugins } = extendSchemaVersion(
  v1Plugins,
  '1.0.2',
  [usernamePasswordSchema, anonymousSchema, phonePasswordSchema],
);

// Register all versions with the factory
const factory = reauthDbVersions([v1, v2]);
const client = factory.client(
  kyselyAdapter({ provider: 'sqlite', db: kysely }),
);
```

<Callout title="Why Schema Versioning?" type="info">
  Schema versioning allows ReAuth to: - Migrate existing databases safely when
  adding new plugins - Support zero-downtime deployments with rolling updates -
  Maintain compatibility with different client versions - Track which plugins
  are available at each version
</Callout>

### Multiple Version Extensions

You can continue extending versions as your application evolves:

```ts
import { apiKeySchema } from '@re-auth/reauth/plugins/api-key';

// Version 1.0.3 - Add API key authentication
const { schema: v3, plugins: v3Plugins } = extendSchemaVersion(
  v2Plugins,
  '1.0.3',
  [apiKeySchema],
);

// Register all versions
const factory = reauthDbVersions([v1, v2, v3]);
```

### Version Migration Workflow

When deploying a new plugin to production:

1. **Add the new version** using `extendSchemaVersion`
2. **Register all versions** with `reauthDbVersions([v1, v2, v3])`
3. **Deploy the new code** - FumaDB automatically migrates the database
4. **Add the plugin** to your engine configuration
5. **Test the new flows** in production

**Example complete migration:**

```ts
// Before: Version 1.0.1 with email/password only
const { schema: v1, plugins: v1Plugins } = reauthDb('1.0.1', [
  emailPasswordSchema,
  jwtSchema,
  sessionSchema,
]);

// After: Add OAuth support
import oauthPlugin, { oauthSchema } from '@re-auth/reauth/plugins/oauth';

const { schema: v2, plugins: v2Plugins } = extendSchemaVersion(
  v1Plugins,
  '1.0.2',
  [oauthSchema],
);

const factory = reauthDbVersions([v1, v2]);
const client = factory.client(
  kyselyAdapter({ provider: 'sqlite', db: kysely }),
);

const engine = createReAuthEngine({
  dbClient: {
    version: async () => await client.version(),
    orm: (version) => client.orm(version),
  },
  plugins: [
    sessionPlugin({}),
    emailPasswordPlugin({
      /* config */
    }),
    oauthPlugin({
      /* config */
    }), // New plugin
  ],
  getUserData: async (subjectId, orm) => ({ id: subjectId }),
});
```

## Plugin Configuration

Each plugin has its own configuration options. Here are examples for common plugins:

### Email Password Plugin

```ts
emailPasswordPlugin({
  sessionTtlSeconds: 3600, // 1 hour sessions
  enableRegistration: true,
  verifyEmail: true,
  verificationCodeTtlMinutes: 15,
  resetCodeTtlMinutes: 10,
  cleanupIntervalMinutes: 60,
  sendCode: async (subject, code, email, type) => {
    // Send verification/reset codes via your email provider
    await emailService.send({
      to: email,
      subject: type === 'verify' ? 'Verify your email' : 'Reset your password',
      template: type === 'verify' ? 'email-verification' : 'password-reset',
      data: { code },
    });
  },
});
```

### Session Plugin

```ts
sessionPlugin({
  cleanupIntervalMinutes: 30, // Clean up every 30 minutes
});
```

### Admin Plugin

```ts
adminPlugin({
  enableAuditLogging: true,
  allowFirstAdminSetup: true,
  firstAdminSetupKey: process.env.ADMIN_SETUP_KEY,
  accessRestrictions: {
    adminOnlyPlugins: ['admin'],
    adminOnlySteps: ['admin.create-user', 'admin.delete-user'],
    allowedRoles: ['admin', 'super-admin'],
  },
});
```

### JWT Plugin

```ts
jwtPlugin({
  issuer: 'https://yourapp.com',
  defaultAccessTokenTtlSeconds: 900, // 15 minutes
  defaultRefreshTokenTtlSeconds: 2592000, // 30 days
  keyRotationIntervalDays: 30,
  enableBlacklist: true,
});
```

## Environmental separation

Use distinct engine instances per environment:

```ts
export const auth = createReAuthEngine({
  // ...
  session: {
    accessTokenTtl: process.env.NODE_ENV === 'production' ? '10m' : '60m',
  },
});
```

Inject environment-aware dependencies (email providers, caches, analytics) when instantiating plugins.

## Validation Checklist

Before deploying to production, ensure:

- [ ] Database client properly configured with FumaDB
- [ ] All required plugins registered and configured
- [ ] `getUserData` function properly implemented
- [ ] Environment variables for external services (email, SMS, OAuth) configured
- [ ] Cleanup scheduler enabled for production
- [ ] Device validation configured if needed
- [ ] Engine hooks properly implemented for logging/monitoring
- [ ] Schema versioning properly set up for database migrations
- [ ] All plugins tested in development environment

## Complete Example

Here's a complete production-ready configuration:

```ts
import createReAuthEngine, {
  reauthDb,
  reauthDbVersions,
} from '@re-auth/reauth';
import { kyselyAdapter } from 'fumadb/adapters/kysely';
import emailPasswordPlugin, {
  emailPasswordSchema,
} from '@re-auth/reauth/plugins/email-password';
import sessionPlugin, { sessionSchema } from '@re-auth/reauth/plugins/session';
import adminPlugin, { adminSchema } from '@re-auth/reauth/plugins/admin';

// Setup database with versioning
const { schema: v1 } = reauthDb('1.0.1', [
  emailPasswordSchema,
  sessionSchema,
  adminSchema,
]);
const factory = reauthDbVersions([v1]);
const client = factory.client(
  kyselyAdapter({ provider: 'postgresql', db: kysely }),
);

const engine = createReAuthEngine({
  dbClient: {
    version: async () => await client.version(),
    orm: (version: any) => client.orm(version),
  },

  plugins: [
    emailPasswordPlugin({
      sessionTtlSeconds: 3600,
      enableRegistration: true,
      verifyEmail: true,
      sendCode: async (subject, code, email, type) => {
        await emailService.send({
          to: email,
          subject:
            type === 'verify' ? 'Verify your email' : 'Reset your password',
          template: type === 'verify' ? 'email-verification' : 'password-reset',
          data: { code },
        });
      },
    }),

    sessionPlugin({
      cleanupIntervalMinutes: 30,
    }),

    adminPlugin({
      enableAuditLogging: true,
      allowFirstAdminSetup: true,
      accessRestrictions: {
        adminOnlyPlugins: ['admin'],
        allowedRoles: ['admin'],
      },
    }),
  ],

  authHooks: [
    {
      type: 'before',
      universal: true,
      fn: async (input, container) => {
        // Log all authentication attempts
        console.log('Auth attempt:', input);
        return input;
      },
    },
  ],

  sessionHooks: [
    {
      type: 'after',
      fn: async (data, container) => {
        // Track session creation
        analytics.track('session_created', { userId: data.subject?.id });
        return data;
      },
    },
  ],

  getUserData: async (subjectId, orm) => {
    const user = await orm.findFirst('subjects', {
      where: (b) => b('id', '=', subjectId),
    });
    return {
      id: user?.id,
      email: user?.email,
      role: user?.role,
    };
  },

  deviceValidator: async (stored, current) => {
    return stored.userAgent === current.userAgent;
  },

  enableCleanupScheduler: true,
});

export { engine };
```

Move on to [HTTP adapters](../http-adapters/overview) to expose these flows.
