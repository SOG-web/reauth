---
title: JWT Plugin
description: JSON Web Token management with JWKS support for distributed authentication.
---

## Overview

The `jwt` plugin provides **JSON Web Token (JWT)** authentication with **JSON Web Key Set (JWKS)** support for distributed authentication systems. It's essential for microservices, mobile apps, and distributed architectures that need stateless token verification.

Key features:

- **JWT Token Generation**: Secure access and refresh token creation
- **JWKS Support**: JSON Web Key Set for distributed token verification
- **Automatic Key Rotation**: Periodic key rotation with grace periods
- **Token Blacklisting**: Secure token revocation and blacklisting
- **Refresh Token Rotation**: Enhanced security with token rotation
- **Distributed Verification**: Verify tokens without database queries
- **Legacy Token Support**: Backward compatibility with existing systems
- **Client Registration**: Register OAuth clients for JWT issuance

<Callout title="Distributed by design" type="success">
  JWT tokens can be verified by any service with access to the public JWKS endpoint,
  enabling truly distributed authentication without database dependencies.
</Callout>

## Installation & Setup

```npm
npm i @re-auth/reauth
```

### Basic Configuration

```ts
import createReAuthEngine, {
  reauthDb,
  reauthDbVersions,
} from '@re-auth/reauth';
import { kyselyAdapter } from 'fumadb/adapters/kysely';
import jwtPlugin from '@re-auth/reauth/plugins/jwt';
import emailPasswordPlugin, {
  emailPasswordSchema,
} from '@re-auth/reauth/plugins/email-password';

// Setup database schema and client
const { schema: v1 } = reauthDb('1.0.1', [emailPasswordSchema]);
const factory = reauthDbVersions([v1]);
const client = factory.client(
  kyselyAdapter({ provider: 'sqlite', db: kysely }),
);

const engine = createReAuthEngine({
  dbClient: {
    version: async () => await client.version(),
    orm: (version: any) => client.orm(version),
  },
  plugins: [
    // Email/password for user authentication
    emailPasswordPlugin({
      sessionTtlSeconds: 0, // Disable legacy sessions
      enableRegistration: true,
    }),

    // JWT plugin for distributed authentication
    jwtPlugin({
      // Token lifetimes
      defaultAccessTokenTtlSeconds: 900, // 15 minutes
      defaultRefreshTokenTtlSeconds: 2592000, // 30 days

      // Key management
      keyRotationIntervalDays: 30,
      keyGracePeriodDays: 7,

      // Security features
      enableBlacklist: true,
      enableRefreshTokenRotation: true,

      // Cleanup configuration
      cleanupIntervalMinutes: 60, // 1 hour

      // Plugin settings
      enableLegacyTokenSupport: false, // JWT-only
      issuer: 'https://auth.yourcompany.com',
    }),
  ],
  getUserData: async (subjectId, orm) => {
    const user = await orm.findFirst('subjects', {
      where: (b) => b('id', '=', subjectId),
    });

    // Include additional data in JWT payload
    const roles = await orm.findMany('subject_roles', {
      where: (b) => b('subject_id', '=', subjectId),
    });

    return {
      id: user?.id,
      email: user?.email,
      roles: roles?.map(r => r.role) || [],
    };
  },
});
```

### With Advanced Security

```ts
jwtPlugin({
  // Short-lived access tokens for security
  defaultAccessTokenTtlSeconds: 300, // 5 minutes
  defaultRefreshTokenTtlSeconds: 86400, // 1 day

  // Frequent key rotation
  keyRotationIntervalDays: 7,
  keyGracePeriodDays: 3,

  // Enhanced security
  enableBlacklist: true,
  enableRefreshTokenRotation: true,
  enableLegacyTokenSupport: false,

  // Production issuer
  issuer: 'https://auth.production.com',

  // Frequent cleanup
  cleanupIntervalMinutes: 30,
});
```

## Configuration

### JWTPluginConfig

| Option                         | Type      | Default | Description                                    |
| ------------------------------ | --------- | ------- | ---------------------------------------------- |
| `defaultAccessTokenTtlSeconds` | `number`  | `900`   | Access token lifetime (seconds)                |
| `defaultRefreshTokenTtlSeconds`| `number`  | `2592000` | Refresh token lifetime (seconds)               |
| `keyRotationIntervalDays`      | `number`  | `10`    | How often to rotate signing keys (days)        |
| `keyGracePeriodDays`           | `number`  | `2`     | Grace period for old keys (days)               |
| `enableBlacklist`              | `boolean` | `true`  | Enable token blacklisting                      |
| `enableRefreshTokenRotation`   | `boolean` | `true`  | Rotate refresh tokens on use                   |
| `cleanupIntervalMinutes`       | `number`  | `60`    | Cleanup frequency in minutes                   |
| `enableLegacyTokenSupport`     | `boolean` | `true`  | Support legacy session tokens                  |
| `issuer`                       | `string`  | `'reauth'` | JWT issuer claim                               |

## Database Schema

The JWT plugin extends the base ReAuth schema with JWT-specific tables:

### `jwks_keys`

JSON Web Key Set storage for token signing and verification.

```sql
CREATE TABLE jwks_keys (
  id UUID PRIMARY KEY,
  key_id VARCHAR(100) NOT NULL UNIQUE,
  key_type VARCHAR(20) NOT NULL, -- 'RSA', 'EC', 'oct'
  algorithm VARCHAR(20) NOT NULL, -- 'RS256', 'ES256', 'HS256'
  public_key TEXT, -- PEM format for public keys
  private_key TEXT, -- Encrypted private key
  created_at TIMESTAMP DEFAULT NOW(),
  expires_at TIMESTAMP,
  is_active BOOLEAN DEFAULT true,
  usage VARCHAR(20) DEFAULT 'sig' -- 'sig', 'enc'
);
```

### `jwt_blacklist` (Optional)

Token blacklist for secure revocation.

```sql
CREATE TABLE jwt_blacklist (
  id UUID PRIMARY KEY,
  token_hash VARCHAR(255) NOT NULL,
  token_id VARCHAR(100), -- JWT 'jti' claim
  subject_id UUID REFERENCES subjects(id),
  revoked_at TIMESTAMP DEFAULT NOW(),
  expires_at TIMESTAMP NOT NULL,
  reason VARCHAR(100) -- 'logout', 'security', 'expired'
);
```

### `oauth_clients`

OAuth client registration for JWT issuance.

```sql
CREATE TABLE oauth_clients (
  id UUID PRIMARY KEY,
  client_id VARCHAR(100) NOT NULL UNIQUE,
  client_secret_hash VARCHAR(255),
  name VARCHAR(100) NOT NULL,
  redirect_uris TEXT[], -- Array of allowed redirect URIs
  scopes TEXT[], -- Array of allowed scopes
  grant_types TEXT[], -- Array of allowed grant types
  is_confidential BOOLEAN DEFAULT false,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);
```

## Authentication Steps

### 1. Get JWKS

**Step name:** `get-jwks`  
**HTTP:** `GET /auth/.well-known/jwks.json`

Retrieve the public JSON Web Key Set for token verification.

**Input:**

```ts
{
  // No input required - public endpoint
}
```

**Output:**

```ts
{
  success: boolean;
  status: 'su';
  jwks: {
    keys: Array<{
      kty: string; // Key type: 'RSA', 'EC', 'oct'
      kid: string; // Key ID
      use: string; // Key use: 'sig', 'enc'
      alg: string; // Algorithm: 'RS256', 'ES256', 'HS256'
      n?: string; // RSA modulus (base64url)
      e?: string; // RSA exponent (base64url)
      x?: string; // EC x coordinate (base64url)
      y?: string; // EC y coordinate (base64url)
      crv?: string; // EC curve name
    }>;
  };
}
```

**Example:**

```ts
// Get JWKS for token verification
const result = await engine.executeStep('jwt', 'get-jwks', {});

if (result.success) {
  console.log('Available signing keys:', result.jwks.keys.length);
  result.jwks.keys.forEach(key => {
    console.log(`Key ${key.kid}: ${key.alg}`);
  });
}
```

**HTTP Endpoint:**

```ts
// JWKS endpoint is automatically exposed
GET /.well-known/jwks.json

// Example response
{
  "keys": [
    {
      "kty": "RSA",
      "kid": "key-1",
      "use": "sig",
      "alg": "RS256",
      "n": "base64url-encoded-modulus",
      "e": "AQAB"
    }
  ]
}
```

### 2. Register OAuth Client

**Step name:** `register-client`  
**HTTP:** `POST /auth/register-client`  
**Auth:** Required (Admin)

Register an OAuth client for JWT token issuance.

**Input:**

```ts
{
  client_id: string; // Unique client identifier
  client_secret?: string; // Optional client secret
  name: string; // Human-readable client name
  redirect_uris?: string[]; // Allowed redirect URIs
  scopes?: string[]; // Allowed scopes
  grant_types?: string[]; // Allowed grant types
  is_confidential?: boolean; // Whether client can keep secrets
}
```

**Output:**

```ts
{
  success: boolean;
  status: 'su' | 'ic' | 'du' | 'aut';
  message: string;
  client?: {
    id: string;
    client_id: string;
    client_secret?: string; // Only returned once
    name: string;
    redirect_uris: string[];
    scopes: string[];
    grant_types: string[];
    is_confidential: boolean;
    created_at: string;
  };
  error?: string | object;
}
```

**Example:**

```ts
// Register a web application client
const result = await engine.executeStep('jwt', 'register-client', {
  client_id: 'web-app-2025',
  name: 'Web Application',
  redirect_uris: [
    'https://app.example.com/callback',
    'https://app.example.com/auth/callback',
  ],
  scopes: ['openid', 'profile', 'email'],
  grant_types: ['authorization_code', 'refresh_token'],
  is_confidential: true,
});

if (result.success) {
  console.log('Client registered:', result.client.client_id);
  console.log('Client secret:', result.client.client_secret); // Store securely!
}
```

## JWT Token Structure

### Access Token

```json
{
  "iss": "https://auth.yourcompany.com",
  "sub": "user-123",
  "aud": "web-app-2025",
  "exp": 1640995200,
  "iat": 1640991600,
  "jti": "token-abc123",
  "scope": "openid profile email",
  "roles": ["user", "premium"],
  "email": "user@example.com"
}
```

### Refresh Token

```json
{
  "iss": "https://auth.yourcompany.com",
  "sub": "user-123",
  "aud": "web-app-2025",
  "exp": 1643587200,
  "iat": 1640991600,
  "jti": "refresh-def456",
  "token_type": "refresh",
  "scope": "openid profile email"
}
```

## Token Verification

### Client-Side Verification

    ```ts
import { createRemoteJWKSet, jwtVerify } from 'jose';

// Create JWKS client
const JWKS = createRemoteJWKSet(
  new URL('https://auth.yourcompany.com/.well-known/jwks.json')
);

async function verifyToken(token: string) {
  try {
    const { payload } = await jwtVerify(token, JWKS, {
      issuer: 'https://auth.yourcompany.com',
      audience: 'web-app-2025',
    });

    return {
      valid: true,
      payload,
      userId: payload.sub,
      roles: payload.roles || [],
      email: payload.email,
    };
  } catch (error) {
    return {
      valid: false,
      error: error.message,
    };
  }
}

// Usage
const token = 'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...';
const result = await verifyToken(token);

if (result.valid) {
  console.log('User:', result.userId);
  console.log('Roles:', result.roles);
} else {
  console.log('Invalid token:', result.error);
}
```

### Server-Side Middleware

```ts
import { createRemoteJWKSet, jwtVerify } from 'jose';

const JWKS = createRemoteJWKSet(
  new URL('https://auth.yourcompany.com/.well-known/jwks.json')
);

async function authMiddleware(req, res, next) {
  const authHeader = req.headers.authorization;
  
  if (!authHeader?.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Missing or invalid authorization header' });
  }

  const token = authHeader.slice(7);

  try {
    const { payload } = await jwtVerify(token, JWKS, {
      issuer: 'https://auth.yourcompany.com',
      audience: 'web-app-2025',
    });

    // Attach user info to request
    req.user = {
      id: payload.sub,
      email: payload.email,
      roles: payload.roles || [],
      scopes: payload.scope?.split(' ') || [],
    };

    next();
  } catch (error) {
    return res.status(401).json({ 
      error: 'Invalid token',
      details: error.message 
    });
  }
}
```

## Token Blacklisting

### Blacklist Token

```ts
// Blacklist a token (e.g., on logout)
const blacklistResult = await engine.getSessionService()
  .getJwkService()
  ?.blacklistToken(token, {
    reason: 'logout',
    subjectId: userId,
  });
```

### Check Blacklist

```ts
// Check if token is blacklisted
const isBlacklisted = await engine.getSessionService()
  .getJwkService()
  ?.isTokenBlacklisted(token);
```

## Background Cleanup

The plugin registers several cleanup tasks:

### 1. Expired JWKS Keys

```ts
engine.registerCleanupTask({
  name: 'expired-jwks-keys',
  pluginName: 'jwt',
  intervalMs: 60 * 60 * 1000, // 1 hour
  enabled: true,
  runner: async (orm, config) => {
    // Remove expired signing keys
    const cleaned = await orm.deleteMany('jwks_keys', {
      where: (b) => b('expires_at', '<', new Date()),
    });
    
    return {
      cleaned: cleaned.count,
      expiredKeysDeleted: cleaned.count,
    };
  },
});
```

### 2. Blacklisted Tokens

```ts
engine.registerCleanupTask({
  name: 'blacklisted-tokens',
  pluginName: 'jwt',
  intervalMs: 2 * 60 * 60 * 1000, // 2 hours
  enabled: true,
  runner: async (orm, config) => {
    // Remove expired blacklisted tokens
    const cleaned = await orm.deleteMany('jwt_blacklist', {
      where: (b) => b('expires_at', '<', new Date()),
    });
    
    return {
      cleaned: cleaned.count,
      blacklistedTokensDeleted: cleaned.count,
    };
  },
});
```

### 3. Expired Refresh Tokens

```ts
engine.registerCleanupTask({
  name: 'expired-refresh-tokens',
  pluginName: 'jwt',
  intervalMs: 3 * 60 * 60 * 1000, // 3 hours
  enabled: true,
  runner: async (orm, config) => {
    // Clean up expired refresh tokens from blacklist
    const cleaned = await orm.deleteMany('jwt_blacklist', {
      where: (b) => b.and(
        b('reason', '=', 'refresh_expired'),
        b('expires_at', '<', new Date())
      ),
    });

      return {
      cleaned: cleaned.count,
      expiredRefreshTokensDeleted: cleaned.count,
    };
  },
});
```

## Profile API

The plugin exposes JWT-related information in user profiles:

```ts
const profile = await engine.getUnifiedProfile('user-123');

// profile.plugins['jwt']
{
  jwt_enabled: true,
  active_keys: 3,
  issuer: 'https://auth.yourcompany.com',
  token_types: ['access', 'refresh'],
  key_rotation_enabled: true,
  blacklist_enabled: true
}
```

## HTTP Adapter Integration

When using HTTP adapters, JWT steps are automatically exposed:

```ts
GET  /.well-known/jwks.json     → jwt:get-jwks
POST /auth/register-client      → jwt:register-client (admin auth)
```

## Security Features

### 1. Key Rotation

```ts
jwtPlugin({
  keyRotationIntervalDays: 30, // Rotate every 30 days
  keyGracePeriodDays: 7, // Keep old keys for 7 days
});

// Automatic key rotation process:
// 1. Generate new signing key
// 2. Add to JWKS (both old and new keys available)
// 3. Wait for grace period
// 4. Remove old key from JWKS
// 5. Clean up expired key from database
```

### 2. Token Blacklisting

```ts
jwtPlugin({
  enableBlacklist: true,
});

// Blacklist tokens on logout or security incidents
await blacklistToken(token, {
  reason: 'logout',
  subjectId: userId,
});
```

### 3. Refresh Token Rotation

```ts
jwtPlugin({
  enableRefreshTokenRotation: true,
});

// On refresh:
// 1. Validate refresh token
// 2. Generate new access token
// 3. Generate new refresh token
// 4. Blacklist old refresh token
// 5. Return new token pair
```

## Complete Example: Microservice Authentication

```ts
// 1. Auth Service - Issue JWT tokens
const authService = createReAuthEngine({
  dbClient,
  plugins: [
    emailPasswordPlugin({
      sessionTtlSeconds: 0, // JWT-only
    }),
    jwtPlugin({
      issuer: 'https://auth.company.com',
      defaultAccessTokenTtlSeconds: 900, // 15 minutes
      defaultRefreshTokenTtlSeconds: 2592000, // 30 days
    }),
  ],
  getUserData: async (subjectId, orm) => ({
    id: subjectId,
    email: await getUserEmail(subjectId),
    roles: await getUserRoles(subjectId),
  }),
});

// 2. User logs in and receives JWT
const loginResult = await authService.executeStep('email-password', 'login', {
  email: 'user@company.com',
  password: 'password123',
});

const { accessToken, refreshToken } = loginResult.token;

// 3. API Service - Verify JWT without database
import { createRemoteJWKSet, jwtVerify } from 'jose';

const JWKS = createRemoteJWKSet(
  new URL('https://auth.company.com/.well-known/jwks.json')
);

app.use(async (req, res, next) => {
  const token = req.headers.authorization?.slice(7);
  
  try {
    const { payload } = await jwtVerify(token, JWKS, {
      issuer: 'https://auth.company.com',
      audience: 'api-service',
    });
    
    req.user = payload;
    next();
  } catch (error) {
    res.status(401).json({ error: 'Invalid token' });
  }
});

// 4. Refresh tokens when needed
app.post('/refresh', async (req, res) => {
  const { refreshToken } = req.body;
  
  try {
    const { payload } = await jwtVerify(refreshToken, JWKS);
    
    // Generate new token pair
    const newTokens = await authService.getSessionService()
      .createSessionWithMetadata('subject', payload.sub, {
        ttlSeconds: 900,
        metadata: { roles: payload.roles },
      });
    
    res.json(newTokens);
  } catch (error) {
    res.status(401).json({ error: 'Invalid refresh token' });
  }
});
```

## Use Cases

### Microservices Architecture

```ts
// Each microservice verifies tokens independently
const services = ['user-service', 'order-service', 'payment-service'];

services.forEach(service => {
  app.use(`/${service}`, authMiddleware);
  
  // Service can trust JWT payload without database calls
  app.get(`/${service}/profile`, (req, res) => {
    res.json({
      userId: req.user.id,
      email: req.user.email,
      roles: req.user.roles,
    });
  });
});
```

### Mobile Application

```ts
// Mobile app stores refresh token securely
const tokenStorage = {
  async getRefreshToken() {
    return await secureStorage.getItem('refresh_token');
  },
  
  async setTokens(accessToken, refreshToken) {
    await secureStorage.setItem('access_token', accessToken);
    await secureStorage.setItem('refresh_token', refreshToken);
  },
};

// Auto-refresh tokens when expired
async function makeAuthenticatedRequest(url, options = {}) {
  let accessToken = await secureStorage.getItem('access_token');
  
  try {
    // Try request with current token
    const response = await fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        'Authorization': `Bearer ${accessToken}`,
      },
    });
    
    if (response.status === 401) {
      // Token expired, refresh it
      const refreshToken = await tokenStorage.getRefreshToken();
      const newTokens = await refreshAccessToken(refreshToken);
      
      await tokenStorage.setTokens(newTokens.accessToken, newTokens.refreshToken);
      
      // Retry request with new token
      return fetch(url, {
        ...options,
        headers: {
          ...options.headers,
          'Authorization': `Bearer ${newTokens.accessToken}`,
        },
      });
    }
    
    return response;
  } catch (error) {
    throw error;
  }
}
```

### Single Page Application

```ts
// SPA with automatic token refresh
class AuthManager {
  private refreshPromise: Promise<string> | null = null;
  
  async getValidToken(): Promise<string> {
    const token = localStorage.getItem('access_token');
    
    if (!token || this.isTokenExpired(token)) {
      return await this.refreshToken();
    }
    
    return token;
  }
  
  private async refreshToken(): Promise<string> {
    if (this.refreshPromise) {
      return await this.refreshPromise;
    }
    
    this.refreshPromise = this.performRefresh();
    const newToken = await this.refreshPromise;
    this.refreshPromise = null;
    
    return newToken;
  }
  
  private async performRefresh(): Promise<string> {
    const refreshToken = localStorage.getItem('refresh_token');
    
    const response = await fetch('/auth/refresh', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ refreshToken }),
    });
    
    if (!response.ok) {
      // Refresh failed, redirect to login
      this.logout();
      throw new Error('Refresh failed');
    }
    
    const { accessToken, refreshToken: newRefreshToken } = await response.json();
    
    localStorage.setItem('access_token', accessToken);
    localStorage.setItem('refresh_token', newRefreshToken);
    
    return accessToken;
  }
}
```

## Next Steps

<Cards>
  <Card
    href="/docs/engine/plugins/session"
    title="Session Plugin"
    description="Combine with enhanced session management."
  />
  <Card
    href="/docs/http-adapters/overview"
    title="HTTP Adapters"
    description="Expose JWT endpoints through HTTP frameworks."
  />
  <Card
    href="/docs/engine/configuration"
    title="Engine Configuration"
    description="Configure token lifetimes and key rotation."
  />
</Cards>