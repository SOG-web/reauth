---
title: API Key Plugin
description: API key authentication for service-to-service communication and developer access.
---

## Overview

The `api-key` plugin provides **API key-based authentication** for service-to-service communication, developer access, and automated systems. It's perfect for:

- **Service-to-service authentication** between microservices
- **Developer API access** with granular permissions
- **Webhook authentication** for external integrations
- **Automated system access** with configurable scopes
- **Usage tracking and monitoring** for API consumption

Key features:

- **Secure key generation** with configurable length and prefixes
- **Scoped permissions** with fine-grained access control
- **Usage tracking** for monitoring API consumption
- **Automatic expiration** with configurable TTL
- **Background cleanup** of expired keys and old usage logs
- **Rate limiting** per API key
- **Audit logging** of key creation and usage

<Callout title="Security first" type="success">
  API keys are hashed before storage and the raw key is only returned once
  during creation. After that, only metadata is available for security.
</Callout>

## Installation & Setup

```npm
npm i @re-auth/reauth
```

### Basic Configuration

```ts
import createReAuthEngine, {
  reauthDb,
  reauthDbVersions,
} from '@re-auth/reauth';
import { kyselyAdapter } from 'fumadb/adapters/kysely';
import apiKeyPlugin, { apiKeySchema } from '@re-auth/reauth/plugins/api-key';
import emailPasswordPlugin, {
  emailPasswordSchema,
} from '@re-auth/reauth/plugins/email-password';

// Setup database schema and client
const { schema: v1 } = reauthDb('1.0.1', [emailPasswordSchema, apiKeySchema]);
const factory = reauthDbVersions([v1]);
const client = factory.client(
  kyselyAdapter({ provider: 'sqlite', db: kysely }),
);

const engine = createReAuthEngine({
  dbClient: {
    version: async () => await client.version(),
    orm: (version: any) => client.orm(version),
  },
  plugins: [
    // Email/password for user authentication
    emailPasswordPlugin({
      sessionTtlSeconds: 3600,
      enableRegistration: true,
    }),

    // API key plugin for service authentication
    apiKeyPlugin({
      // Key configuration
      keyLength: 32,
      keyPrefix: 'ak_',
      defaultTtlDays: 365,

      // User limits
      maxKeysPerUser: 10,

      // Permissions and scopes
      requireScopes: true,
      allowedScopes: ['read', 'write', 'delete', 'admin'],

      // Usage tracking
      enableUsageTracking: true,

      // Cleanup configuration
      cleanupIntervalMinutes: 60, // 1 hour
    }),
  ],
  getUserData: async (subjectId, orm) => {
    const user = await orm.findFirst('subjects', {
      where: (b) => b('id', '=', subjectId),
    });
    return user ?? {};
  },
});
```

### With Custom Scopes

```ts
apiKeyPlugin({
  keyLength: 40,
  keyPrefix: 'sk_', // Secret key prefix
  defaultTtlDays: 90, // 3 months
  maxKeysPerUser: 5,
  requireScopes: true,
  allowedScopes: [
    'users:read',
    'users:write',
    'orders:read',
    'orders:write',
    'payments:read',
    'payments:write',
    'admin:all',
  ],
  enableUsageTracking: true,
  cleanupIntervalMinutes: 30, // More frequent cleanup
});
```

## Configuration

### ApiKeyConfig

| Option                   | Type       | Default                                | Description                         |
| ------------------------ | ---------- | -------------------------------------- | ----------------------------------- |
| `keyLength`              | `number`   | `32`                                   | Length of generated API key         |
| `keyPrefix`              | `string`   | `'ak_'`                                | Prefix for generated keys           |
| `defaultTtlDays`         | `number`   | `365`                                  | Default expiration period in days   |
| `maxKeysPerUser`         | `number`   | `10`                                   | Maximum API keys per user           |
| `allowedScopes`          | `string[]` | `['read', 'write', 'delete', 'admin']` | Available permission scopes         |
| `requireScopes`          | `boolean`  | `false`                                | Whether scopes are mandatory        |
| `enableUsageTracking`    | `boolean`  | `false`                                | Enable usage logging and monitoring |
| `cleanupIntervalMinutes` | `number`   | `60`                                   | Cleanup frequency in minutes        |

## Database Schema

The API key plugin extends the base ReAuth schema with several tables:

### `api_keys`

API key storage with hashed keys for security.

```sql
CREATE TABLE api_keys (
  id UUID PRIMARY KEY,
  subject_id UUID NOT NULL REFERENCES subjects(id) ON DELETE CASCADE,
  name VARCHAR(100) NOT NULL,
  key_hash VARCHAR(255) NOT NULL UNIQUE, -- Hashed API key
  permissions TEXT[], -- Array of permission strings
  scopes TEXT[], -- Array of scope strings
  last_used_at TIMESTAMP NULL,
  expires_at TIMESTAMP NULL,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);
```

### `api_key_usage_logs` (Optional)

Usage tracking for monitoring API consumption.

```sql
CREATE TABLE api_key_usage_logs (
  id UUID PRIMARY KEY,
  api_key_id UUID NOT NULL REFERENCES api_keys(id) ON DELETE CASCADE,
  endpoint VARCHAR(255),
  ip_address INET,
  user_agent TEXT,
  success BOOLEAN NOT NULL,
  error_message TEXT,
  used_at TIMESTAMP DEFAULT NOW()
);
```

## Authentication Steps

### 1. Create API Key

**Step name:** `create-api-key`  
**HTTP:** `POST /auth/create-api-key`  
**Auth:** Required

Create a new API key for the authenticated user.

**Input:**

```ts
{
  name: string; // Human-readable name for the key
  permissions?: string[]; // Custom permissions
  scopes?: string[]; // Access scopes
  expires_at?: string; // ISO date string
  ttl_days?: number; // Alternative to expires_at
}
```

**Output:**

```ts
{
  success: boolean;
  status: 'su' | 'ic' | 'du' | 'aut' | 'tl';
  message: string;
  api_key?: string; // Raw API key (only returned once!)
  metadata?: {
    id: string;
    name: string;
    subject_id: string;
    permissions: string[];
    scopes: string[];
    expires_at?: string;
    is_active: boolean;
    created_at: string;
  };
  error?: string | object;
}
```

**Behavior:**

- Validates user is authenticated
- Checks `maxKeysPerUser` limit
- Generates secure random key with configured prefix
- Hashes key before storage (raw key never stored)
- Assigns permissions and scopes
- Sets expiration based on `expires_at` or `ttl_days`
- Returns raw key only once for immediate use

**Example:**

```ts
// Create API key for service integration
const result = await engine.executeStep('api-key', 'create-api-key', {
  name: 'Production Service Integration',
  scopes: ['users:read', 'orders:write'],
  ttl_days: 90, // 3 months
});

if (result.success) {
  console.log('API Key:', result.api_key); // ak_abc123...
  console.log('Key ID:', result.metadata.id);

  // Store the key securely - it's only returned once!
  await storeApiKeySecurely(result.api_key, result.metadata);
}
```

### 2. Authenticate with API Key

**Step name:** `authenticate-api-key`  
**HTTP:** `POST /auth/authenticate-api-key`

Authenticate using an API key and receive a session token.

**Input:**

```ts
{
  api_key: string; // The API key to authenticate with
}
```

**Output:**

```ts
{
  success: boolean;
  status: 'su' | 'ic' | 'nf' | 'aut' | 'exp';
  message: string;
  token?: Token; // Session token for API access
  subject?: {
    id: string;
    type: 'api-key';
    keyId: string;
    scopes: string[];
    permissions: string[];
  };
  error?: string | object;
}
```

**Behavior:**

- Validates API key format and prefix
- Hashes input key and looks up in database
- Checks if key is active and not expired
- Validates key belongs to active subject
- Updates `last_used_at` timestamp
- Creates session token for API access
- Logs usage if tracking is enabled

**Example:**

```ts
// Authenticate with API key
const result = await engine.executeStep('api-key', 'authenticate-api-key', {
  api_key: 'ak_abc123def456...',
});

if (result.success) {
  // Use the session token for API requests
  const sessionToken = result.token.accessToken;

  // Make authenticated API calls
  const response = await fetch('/api/users', {
    headers: {
      Authorization: `Bearer ${sessionToken}`,
    },
  });
}
```

### 3. List API Keys

**Step name:** `list-api-keys`  
**HTTP:** `GET /auth/list-api-keys`  
**Auth:** Required

List all API keys for the authenticated user.

**Input:**

```ts
{
  page?: number; // Default: 1
  limit?: number; // Default: 50
  includeInactive?: boolean; // Include revoked keys
}
```

**Output:**

```ts
{
  success: boolean;
  status: 'su' | 'aut';
  api_keys: Array<{
    id: string;
    name: string;
    permissions: string[];
    scopes: string[];
    last_used_at?: string;
    expires_at?: string;
    is_active: boolean;
    created_at: string;
    // Note: Raw API key is never returned
  }>;
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  }
}
```

**Example:**

```ts
const result = await engine.executeStep('api-key', 'list-api-keys', {
  page: 1,
  limit: 20,
  includeInactive: false,
});

if (result.success) {
  result.api_keys.forEach((key) => {
    console.log(`${key.name}: ${key.scopes.join(', ')}`);
    console.log(`Last used: ${key.last_used_at || 'Never'}`);
    console.log(`Expires: ${key.expires_at || 'Never'}`);
  });
}
```

### 4. Update API Key

**Step name:** `update-api-key`  
**HTTP:** `PUT /auth/update-api-key`  
**Auth:** Required

Update API key metadata (name, permissions, scopes).

**Input:**

```ts
{
  key_id: string; // ID of the key to update
  name?: string; // New name
  permissions?: string[]; // New permissions
  scopes?: string[]; // New scopes
  is_active?: boolean; // Enable/disable key
}
```

**Output:**

```ts
{
  success: boolean;
  status: 'su' | 'ic' | 'nf' | 'aut';
  message: string;
  metadata?: ApiKeyMetadata;
  error?: string | object;
}
```

**Example:**

```ts
// Update API key permissions
const result = await engine.executeStep('api-key', 'update-api-key', {
  key_id: 'key-123',
  name: 'Updated Service Integration',
  scopes: ['users:read', 'users:write', 'orders:read'], // Added users:write
  is_active: true,
});
```

### 5. Revoke API Key

**Step name:** `revoke-api-key`  
**HTTP:** `DELETE /auth/revoke-api-key`  
**Auth:** Required

Revoke (disable) an API key.

**Input:**

```ts
{
  key_id: string; // ID of the key to revoke
  reason?: string; // Reason for revocation
}
```

**Output:**

```ts
{
  success: boolean;
  status: 'su' | 'nf' | 'aut';
  message: string;
  error?: string | object;
}
```

**Example:**

```ts
// Revoke compromised API key
const result = await engine.executeStep('api-key', 'revoke-api-key', {
  key_id: 'key-123',
  reason: 'Key compromised - rotated immediately',
});
```

## Usage Tracking

When `enableUsageTracking` is enabled, the plugin logs API key usage:

### Usage Log Entry

```ts
{
  id: string;
  api_key_id: string;
  endpoint?: string; // API endpoint accessed
  ip_address?: string; // Client IP address
  user_agent?: string; // Client user agent
  success: boolean; // Whether request succeeded
  error_message?: string; // Error details if failed
  used_at: Date; // Timestamp of usage
}
```

### Query Usage Logs

```ts
// Get usage statistics for an API key
const usageLogs = await orm.findMany('api_key_usage_logs', {
  where: (b) => b('api_key_id', '=', keyId),
  orderBy: [['used_at', 'desc']],
  limit: 100,
});

// Analyze usage patterns
const successRate =
  usageLogs.filter((log) => log.success).length / usageLogs.length;
const uniqueEndpoints = new Set(usageLogs.map((log) => log.endpoint)).size;
const recentUsage = usageLogs.filter(
  (log) => new Date(log.used_at) > new Date(Date.now() - 24 * 60 * 60 * 1000),
).length;
```

## Background Cleanup

The plugin registers cleanup tasks for:

### `cleanupExpiredApiKeys(orm)`

Disables API keys that have expired.

### `cleanupOldUsageLogs(orm, olderThanDays)`

Removes usage logs older than the specified period.

**Cleanup configuration:**

```ts
apiKeyPlugin({
  enableUsageTracking: true,
  cleanupIntervalMinutes: 60, // Run cleanup every hour
  // cleanupUsageOlderThanDays: 90, // Keep usage logs for 90 days
});
```

## Profile API

The plugin exposes API key information in user profiles:

```ts
const profile = await engine.getUnifiedProfile('user-123');

// profile.plugins['api-key']
{
  total_keys: 3,
  active_keys: 2,
  expired_keys: 1,
  keys: [
    {
      id: 'key-1',
      name: 'Production Service',
      scopes: ['read', 'write'],
      last_used_at: '2025-01-15T10:30:00Z',
      expires_at: '2025-04-15T10:30:00Z',
      is_active: true
    },
    // ... other keys
  ]
}
```

## HTTP Adapter Integration

When using HTTP adapters, API key steps are automatically exposed:

```ts
POST /auth/create-api-key       → api-key:create-api-key (auth)
POST /auth/authenticate-api-key → api-key:authenticate-api-key
GET  /auth/list-api-keys        → api-key:list-api-keys (auth)
PUT  /auth/update-api-key       → api-key:update-api-key (auth)
DELETE /auth/revoke-api-key     → api-key:revoke-api-key (auth)
```

## Security Best Practices

### 1. Key Storage

- **Never store raw API keys** in your database
- **Hash keys before storage** using secure hashing algorithms
- **Return raw keys only once** during creation
- **Use secure key prefixes** to identify key types

### 2. Key Rotation

```ts
// Rotate API key by creating new one and revoking old
const newKey = await createApiKey({
  name: 'Rotated Service Key',
  scopes: ['read', 'write'],
  ttl_days: 90,
});

// Revoke old key after new one is deployed
await revokeApiKey({
  key_id: oldKeyId,
  reason: 'Key rotated for security',
});
```

### 3. Scope Management

```ts
// Use principle of least privilege
const readOnlyKey = await createApiKey({
  name: 'Read-Only Integration',
  scopes: ['read'], // Only read access
});

const adminKey = await createApiKey({
  name: 'Admin Operations',
  scopes: ['admin'], // Full access
  ttl_days: 30, // Shorter TTL for admin keys
});
```

### 4. Monitoring and Alerting

```ts
// Monitor for suspicious usage patterns
const recentUsage = await getUsageLogs(keyId, {
  since: new Date(Date.now() - 24 * 60 * 60 * 1000),
});

if (recentUsage.length > 1000) {
  await alertSecurityTeam({
    type: 'HIGH_USAGE',
    keyId,
    usageCount: recentUsage.length,
  });
}
```

## Complete Example: Service Integration

```ts
// 1. User creates API key for their service
const createResult = await engine.executeStep('api-key', 'create-api-key', {
  name: 'My Service Integration',
  scopes: ['users:read', 'orders:write'],
  ttl_days: 365,
});

// Store the API key securely (only returned once!)
const apiKey = createResult.api_key;
await secureStorage.store('service-api-key', apiKey);

// 2. Service authenticates with API key
const authResult = await engine.executeStep('api-key', 'authenticate-api-key', {
  api_key: apiKey,
});

if (authResult.success) {
  // Use session token for API requests
  const sessionToken = authResult.token.accessToken;

  // Make authenticated requests
  const users = await fetch('/api/users', {
    headers: {
      Authorization: `Bearer ${sessionToken}`,
    },
  });
}

// 3. Monitor usage and rotate keys
const usageStats = await engine.executeStep('api-key', 'list-api-keys', {
  includeInactive: false,
});

// Check for keys approaching expiration
const expiringSoon = usageStats.api_keys.filter((key) => {
  const expiresAt = new Date(key.expires_at);
  const thirtyDaysFromNow = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);
  return expiresAt < thirtyDaysFromNow;
});

// Rotate expiring keys
for (const key of expiringSoon) {
  await rotateApiKey(key.id);
}
```

## Use Cases

### Microservice Authentication

```ts
// Service A authenticates with Service B
const authResult = await serviceB.executeStep(
  'api-key',
  'authenticate-api-key',
  {
    api_key: process.env.SERVICE_A_API_KEY,
  },
);

const serviceToken = authResult.token.accessToken;

// Make authenticated calls between services
const response = await fetch('http://service-b/api/data', {
  headers: {
    Authorization: `Bearer ${serviceToken}`,
  },
});
```

### Developer API Access

```ts
// Developer creates API key through dashboard
const devKey = await createApiKey({
  name: 'Development Environment',
  scopes: ['read', 'write'],
  ttl_days: 30, // Short-lived for development
});

// Use in development scripts
const api = new APIClient(devKey);
const users = await api.getUsers();
```

### Webhook Authentication

```ts
// External service authenticates webhook calls
app.post('/webhook', async (req, res) => {
  const apiKey = req.headers['x-api-key'];

  const authResult = await engine.executeStep(
    'api-key',
    'authenticate-api-key',
    {
      api_key: apiKey,
    },
  );

  if (!authResult.success) {
    return res.status(401).json({ error: 'Invalid API key' });
  }

  // Process webhook with authenticated context
  await processWebhook(req.body, authResult.subject);
  res.json({ success: true });
});
```

## Next Steps

<Cards>
  <Card
    href="/docs/engine/plugins/admin"
    title="Admin Plugin"
    description="Manage API keys through admin interface."
  />
  <Card
    href="/docs/engine/plugins/session"
    title="Session Plugin"
    description="Configure session management for API key authentication."
  />
  <Card
    href="/docs/http-adapters/overview"
    title="HTTP Adapters"
    description="Expose API key endpoints through HTTP frameworks."
  />
</Cards>
