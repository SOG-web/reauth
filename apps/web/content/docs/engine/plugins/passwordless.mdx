---
title: Passwordless Plugin
description: Frictionless authentication via magic links and WebAuthn (passkeys).
---

## Overview

The `passwordless` plugin eliminates passwords entirely by supporting two modern authentication methods:

- **Magic Links**: One-time tokens sent via email that authenticate users when clicked
- **WebAuthn**: Biometric and hardware-based authentication using FIDO2 standards (passkeys, Face ID, Touch ID, security keys)

The plugin manages token generation, verification, credential storage, and background cleanup of expired magic links.

<Callout title="⚠️ PLUGIN DEPENDENCY (Optional)" type="warning">
  If you set `useEmailPlugin: true` for magic links, the `email-password` plugin
  **MUST** be registered **BEFORE** this plugin. The engine will throw an error
  at initialization if the email plugin is missing. Alternatively, set
  `useEmailPlugin: false` and provide a `getEmail` function to fetch email
  addresses.
</Callout>

<Callout title="Choose Your Method" type="info">
  Enable `magicLinks`, `webauthn`, or both. The plugin validates that at least
  one method is configured at initialization.
</Callout>

## Installation & Setup

```npm
npm i @re-auth/reauth
```

### Magic Links Only

```ts
import createReAuthEngine, {
  reauthDb,
  reauthDbVersions,
} from '@re-auth/reauth';
import { kyselyAdapter } from 'fumadb/adapters/kysely';
import passwordlessPlugin, {
  passwordlessSchema,
} from '@re-auth/reauth/plugins/passwordless';

// Setup database schema and client
const { schema: v1 } = reauthDb('1.0.1', [passwordlessSchema]);
const factory = reauthDbVersions([v1]);
const client = factory.client(
  kyselyAdapter({ provider: 'sqlite', db: kysely }),
);

const engine = createReAuthEngine({
  dbClient: {
    version: async () => await client.version(),
    orm: (version: any) => client.orm(version),
  },
  plugins: [
    // ✅ REQUIRED if useEmailPlugin: true - register email-password plugin FIRST
    emailPasswordPlugin({
      verifyEmail: true,
      sendEmail: async (to, type, payload) => {
        await sendEmail(to, type, payload);
      },
    }),
    // Then register passwordless plugin
    passwordlessPlugin({
      magicLinks: true,
      sessionTtlSeconds: 3600, // 1 hour sessions
      magicLinkTtlMinutes: 30, // links expire in 30 minutes
      cleanupIntervalMinutes: 60, // cleanup every hour
      useEmailPlugin: true, // Uses email-password plugin for email lookups
      sendMagicLink: async (email, token, subject) => {
        const link = `https://yourapp.com/auth/verify?token=${token}`;
        await emailService.send({
          to: email,
          subject: 'Sign in to your account',
          html: `<a href="${link}">Click here to sign in</a><br>This link expires in 30 minutes.`,
        });
      },
    }),
  ],
  getUserData: async (subjectId, orm) => {
    const user = await orm.findFirst('subjects', {
      where: (b) => b('id', '=', subjectId),
    });
    return user ?? {};
  },
});
```

### WebAuthn Only

```ts
passwordlessPlugin({
  webauthn: true,
  rpId: 'yourapp.com', // Your domain
  rpName: 'Your App Name',
  sessionTtlSeconds: 3600,
  useEmailPlugin: false,
  getEmail: async (input) => {
    // Extract email from input or return from database
    return input.email;
  },
});
```

### Both Methods

```ts
passwordlessPlugin({
  magicLinks: true,
  webauthn: true,
  rpId: 'yourapp.com',
  rpName: 'Your App',
  sessionTtlSeconds: 3600,
  magicLinkTtlMinutes: 30,
  cleanupIntervalMinutes: 60,
  useEmailPlugin: true,
  sendMagicLink: async (email, token, subject) => {
    // Send email with magic link
  },
});
```

## Configuration

### PasswordlessConfig

| Option                   | Type                                       | Default | Description                                                                               |
| ------------------------ | ------------------------------------------ | ------- | ----------------------------------------------------------------------------------------- |
| `magicLinks`             | `boolean`                                  | `false` | Enable magic link authentication.                                                         |
| `sendMagicLink`          | `(email, token, subject) => Promise<void>` | -       | **Required** if `magicLinks: true`. Function to send magic link emails.                   |
| `webauthn`               | `boolean`                                  | `false` | Enable WebAuthn/passkey authentication.                                                   |
| `rpId`                   | `string`                                   | -       | **Required** if `webauthn: true`. Relying Party ID (your domain).                         |
| `rpName`                 | `string`                                   | -       | **Required** if `webauthn: true`. Relying Party Name (your app name).                     |
| `sessionTtlSeconds`      | `number`                                   | `3600`  | Session token TTL in seconds.                                                             |
| `magicLinkTtlMinutes`    | `number`                                   | `30`    | Magic link expiration in minutes. Must be between 1 and 1440 (24 hours).                  |
| `cleanupIntervalMinutes` | `number`                                   | `60`    | Interval between cleanup runs. Must be between 1 and 1440.                                |
| `useEmailPlugin`         | `boolean`                                  | `true`  | Use `email-password` plugin for email resolution. If `false`, provide `getEmail`.         |
| `getEmail`               | `(input) => Promise<string>`               | -       | **Required** if `useEmailPlugin: false`. Extract email from input or fetch from database. |

<Callout title="Configuration validation" type="warn">
  At least one of `magicLinks` or `webauthn` must be `true`. The plugin throws
  an initialization error if both are disabled.
</Callout>

## Magic Link Authentication

### 1. Send Magic Link

**Step name:** `send-magic-link`  
**HTTP:** `POST /auth/send-magic-link`

Request a magic link to be sent to the user's email.

**Input:**

```ts
{
  email: string;
  others?: Record<string, any>;
}
```

**Output:**

```ts
{
  success: boolean;
  status: 'su' | 'ic' | 'nf'; // success | invalid config | not found
  message: string;
  others?: {
    email: string;
    expires_at: string; // ISO timestamp
  };
}
```

**Behavior:**

- Validates email format via ArkType schema
- Cleans up expired magic links before creating a new one
- Generates a cryptographically secure token (32 bytes, base64url-encoded)
- Stores hashed token in `magic_links` table with expiration
- Calls `sendMagicLink(email, token, subject)` to deliver the link
- Returns success even if email not found (prevents email enumeration)

**Example:**

```ts
const result = await engine.executeStep('passwordless', 'send-magic-link', {
  email: 'user@example.com',
  others: { utm_source: 'newsletter' },
});

if (result.success) {
  console.log('Magic link sent! Expires at:', result.others.expires_at);
}
```

**Security notes:**

- Tokens are hashed using SHA-256 before storage
- One-time use: marking `used_at` prevents replay attacks
- Time-limited: enforced by `expires_at` timestamp
- Rate limiting should be applied at the HTTP adapter level

### 2. Verify Magic Link

**Step name:** `verify-magic-link`  
**HTTP:** `POST /auth/verify-magic-link`

Verify a magic link token and authenticate the user.

**Input:**

```ts
{
  magic_token: string;
  others?: Record<string, any>;
}
```

**Output:**

```ts
{
  success: boolean;
  status: 'su' | 'ic' | 'nf' | 'ex'; // success | invalid | not found | expired/used
  message: string;
  token?: Token;
  subject?: any;
  others?: {
    email: string;
    authentication_method: 'magic_link';
  };
}
```

**Behavior:**

- Hashes the provided token and looks up in `magic_links`
- Rejects if already used (`used_at` is set)
- Rejects if expired (`expires_at < now`)
- Marks link as used by setting `used_at = now()`
- Creates a session token via `engine.createSessionFor`
- Returns subject data and session token

**Example:**

```ts
// Token typically comes from URL query parameter
const result = await engine.executeStep('passwordless', 'verify-magic-link', {
  magic_token: 'abc123...',
});

if (result.status === 'ex') {
  console.log('Magic link expired or already used');
} else if (result.success) {
  console.log('Authenticated:', result.subject);
  console.log('Session token:', result.token);
}
```

**User experience flow:**

1. User clicks magic link: `https://yourapp.com/auth/verify?token=abc123...`
2. Your app extracts `token` from query params
3. Frontend calls `POST /auth/verify-magic-link` with `{ magic_token: token }`
4. On success, store `token` in cookies/localStorage and redirect to dashboard

## WebAuthn Authentication

<Callout title="Coming soon" type="info">
  WebAuthn steps (`register-webauthn`, `authenticate-webauthn`,
  `list-credentials`, `revoke-credential`) are defined in the plugin but
  currently commented out pending FIDO2 library integration. Track progress in
  the repository.
</Callout>

### Planned Steps

- **`register-webauthn`**: Register a new passkey/credential
- **`authenticate-webauthn`**: Authenticate using a registered credential
- **`list-credentials`**: List all credentials for a user
- **`revoke-credential`**: Revoke/delete a credential

## Background Cleanup

The plugin registers a cleanup task (when `magicLinks: true`) that runs every `cleanupIntervalMinutes` to delete expired and used magic links.

**Cleanup behavior:**

- Deletes `magic_links` where `expires_at < NOW()`
- Deletes `magic_links` where `used_at IS NOT NULL AND used_at < NOW() - 24 hours` (cleanup used links after 24h)
- Returns count of deleted records for monitoring

**Disable cleanup:**

```ts
const engine = createReAuthEngine({
  // ...
  enableCleanupScheduler: false, // disables all cleanup tasks
});
```

**Adjust interval:**

```ts
passwordlessPlugin({
  cleanupIntervalMinutes: 120, // cleanup every 2 hours
  // ...
});
```

<Callout title="Cleanup constraints" type="info">
  `cleanupIntervalMinutes` must be between 1 and 1440 (24 hours). The plugin
  validates this on initialization.
</Callout>

## Profile API

The plugin exposes a `getProfile` method for retrieving user credentials and active magic links:

```ts
const profile = await engine.getUnifiedProfile('user-123');

// profile.plugins['passwordless']
{
  credentials: [
    // (WebAuthn credentials when implemented)
    {
      id: 'cred-xyz',
      name: 'iPhone Face ID',
      created_at: '2025-10-03T12:00:00Z',
      last_used_at: '2025-10-03T14:30:00Z',
      is_active: true,
      transports: ['internal']
    }
  ],
  magic_links: [
    {
      id: 'ml-abc',
      email: 'user@example.com',
      created_at: '2025-10-03T15:00:00Z',
      expires_at: '2025-10-03T15:30:00Z'
    }
  ]
}
```

Only **active** magic links (not used, not expired) appear in the profile.

## Integration with Email Plugin

When `useEmailPlugin: true`, the passwordless plugin requires the `email-password` plugin to be registered **first**:

```ts
const engine = createReAuthEngine({
  plugins: [
    emailPasswordPlugin({
      /* ... */
    }),
    passwordlessPlugin({
      useEmailPlugin: true,
      magicLinks: true,
      // ...
    }),
  ],
});
```

This allows magic links to query the `identities` table to find existing email accounts.

If you manage emails externally, set `useEmailPlugin: false` and provide `getEmail`:

```ts
passwordlessPlugin({
  useEmailPlugin: false,
  getEmail: async (input) => {
    // Fetch email from your custom user table
    const user = await db.query('SELECT email FROM users WHERE username = ?', [
      input.username,
    ]);
    return user?.email ?? '';
  },
  // ...
});
```

## HTTP Adapter Integration

When using HTTP adapters, magic link steps are automatically exposed:

```ts
POST /auth/send-magic-link        → passwordless:send-magic-link
POST /auth/verify-magic-link      → passwordless:verify-magic-link
```

WebAuthn steps (when enabled):

```ts
POST /auth/register-webauthn      → passwordless:register-webauthn
POST /auth/authenticate-webauthn  → passwordless:authenticate-webauthn
GET  /auth/list-credentials       → passwordless:list-credentials (requires auth)
POST /auth/revoke-credential      → passwordless:revoke-credential (requires auth)
```

## Security Considerations

<Steps>
  <Step>
    <h4>1. Token Entropy</h4>
    <p>
      Magic link tokens are generated using <code>crypto.randomBytes(32)</code>{' '}
      and encoded as base64url (43 characters), providing ~256 bits of
      entropy—resistant to brute force attacks.
    </p>
  </Step>
  <Step>
    <h4>2. Hash Storage</h4>
    <p>
      Tokens are hashed with SHA-256 before database storage. Even if the
      database is compromised, attackers cannot reconstruct valid magic links.
    </p>
  </Step>
  <Step>
    <h4>3. One-Time Use</h4>
    <p>
      Once <code>used_at</code> is set, the link cannot be used again,
      preventing replay attacks.
    </p>
  </Step>
  <Step>
    <h4>4. Time Limits</h4>
    <p>
      Links expire after <code>magicLinkTtlMinutes</code> (default 30 minutes).
      Adjust based on your security requirements vs. user convenience.
    </p>
  </Step>
  <Step>
    <h4>5. Email Enumeration Protection</h4>
    <p>
      The <code>send-magic-link</code> step returns success even if the email
      doesn't exist, preventing attackers from discovering valid accounts.
    </p>
  </Step>
  <Step>
    <h4>6. Rate Limiting</h4>
    <p>
      Apply rate limiting at the HTTP adapter or gateway level to prevent abuse
      (e.g., max 3 magic link requests per email per hour).
    </p>
  </Step>
</Steps>

## Example: Complete Magic Link Flow

```ts
// 1. User requests magic link
const sendResult = await engine.executeStep('passwordless', 'send-magic-link', {
  email: 'user@example.com',
});

// sendMagicLink function sends email:
// "Click here to sign in: https://yourapp.com/auth/verify?token=abc123..."

// 2. User clicks link, your app extracts token
const urlParams = new URLSearchParams(window.location.search);
const token = urlParams.get('token');

// 3. Frontend verifies token
const verifyResult = await fetch('/auth/verify-magic-link', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ magic_token: token }),
});

const data = await verifyResult.json();

if (data.success) {
  // Store session token
  localStorage.setItem('authToken', data.token.accessToken);
  // Redirect to dashboard
  window.location.href = '/dashboard';
} else {
  // Show error: expired, invalid, or already used
  alert(data.message);
}
```

## Next Steps

<Cards>
  <Card
    href="/docs/engine/plugins/email-password"
    title="Email + Password Plugin"
    description="Combine passwordless with traditional email/password flows."
  />
  <Card
    href="/docs/engine/plugins/organization"
    title="Organization Plugin"
    description="Add multi-tenant workspace support with role-based access."
  />
  <Card
    href="/docs/engine/configuration"
    title="Engine Configuration"
    description="Configure session TTLs, cleanup intervals, and plugin order."
  />
</Cards>
