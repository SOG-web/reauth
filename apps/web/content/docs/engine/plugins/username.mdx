---
title: Username Plugin
description: Username-based authentication without email requirements.
---

## Overview

The `username` plugin provides **username-based authentication** for applications that prefer usernames over email addresses. It's perfect for gaming platforms, forums, and applications where users want memorable usernames instead of email-based logins.

Key features:

- **Username Registration**: Create accounts with custom usernames
- **Password Authentication**: Secure password-based login
- **Password Changes**: Allow users to update their passwords
- **Username Uniqueness**: Automatic username conflict resolution
- **Password Reset**: Optional username-based password reset
- **Session Management**: Full session lifecycle support
- **Cleanup Tasks**: Automatic cleanup of expired reset codes

<Callout title="No email required" type="success">
  The username plugin allows users to register and authenticate using only a
  username and password, without requiring email addresses.
</Callout>

## Installation & Setup

```npm
npm i @re-auth/reauth
```

### Basic Configuration

```ts
import createReAuthEngine, {
  reauthDb,
  reauthDbVersions,
} from '@re-auth/reauth';
import { kyselyAdapter } from 'fumadb/adapters/kysely';
import usernamePasswordPlugin, {
  usernamePasswordSchema,
} from '@re-auth/reauth/plugins/username';

// Setup database schema and client
const { schema: v1 } = reauthDb('1.0.1', [usernamePasswordSchema]);
const factory = reauthDbVersions([v1]);
const client = factory.client(
  kyselyAdapter({ provider: 'sqlite', db: kysely }),
);

const engine = createReAuthEngine({
  dbClient: {
    version: async () => await client.version(),
    orm: (version: any) => client.orm(version),
  },
  plugins: [
    // Username-based authentication
    usernamePasswordPlugin({
      sessionTtlSeconds: 3600, // 1 hour sessions
      enableRegistration: true,
      enableResetByUsername: false, // Disable password reset for simplicity
      cleanupIntervalMinutes: 60, // Clean up every hour
    }),
  ],
  getUserData: async (subjectId, orm) => {
    const user = await orm.findFirst('subjects', {
      where: (b) => b('id', '=', subjectId),
    });
    return user ?? {};
  },
});
```

### With Password Reset

```ts
usernamePasswordPlugin({
  sessionTtlSeconds: 7200, // 2 hour sessions
  enableRegistration: true,

  // Enable password reset functionality
  enableResetByUsername: true,
  resetCodeTtlMinutes: 15, // Reset codes expire in 15 minutes
  resetCodeLength: 6, // 6-digit reset codes

  // Cleanup configuration
  cleanupIntervalMinutes: 30, // More frequent cleanup
});
```

## Configuration

### UsernamePasswordConfig

| Option                   | Type      | Default | Description                            |
| ------------------------ | --------- | ------- | -------------------------------------- |
| `sessionTtlSeconds`      | `number`  | `3600`  | Session lifetime in seconds            |
| `enableRegistration`     | `boolean` | `true`  | Allow new user registration            |
| `enableResetByUsername`  | `boolean` | `false` | Enable password reset via username     |
| `resetCodeTtlMinutes`    | `number`  | `15`    | Password reset code lifetime (minutes) |
| `resetCodeLength`        | `number`  | `6`     | Length of password reset codes         |
| `cleanupIntervalMinutes` | `number`  | `60`    | Cleanup frequency in minutes           |

## Database Schema

The username plugin extends the base ReAuth schema with username-specific tables:

### `subjects`

User accounts with username-based authentication.

```sql
CREATE TABLE subjects (
  id UUID PRIMARY KEY,
  username VARCHAR(50) NOT NULL UNIQUE,
  password_hash VARCHAR(255) NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  last_login_at TIMESTAMP,
  is_active BOOLEAN DEFAULT true,
  metadata JSONB
);
```

### `password_reset_codes` (Optional)

Password reset codes when reset functionality is enabled.

```sql
CREATE TABLE password_reset_codes (
  id UUID PRIMARY KEY,
  subject_id UUID NOT NULL REFERENCES subjects(id) ON DELETE CASCADE,
  code VARCHAR(10) NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  expires_at TIMESTAMP NOT NULL,
  used_at TIMESTAMP NULL,
  ip_address INET,
  user_agent TEXT
);
```

## Authentication Steps

### 1. Register

**Step name:** `register`  
**HTTP:** `POST /auth/register`  
**Auth:** Not required

Create a new user account with username and password.

**Input:**

```ts
{
  username: string; // Unique username
  password: string; // User's password
  metadata?: Record<string, any>; // Optional user metadata
}
```

**Output:**

```ts
{
  success: boolean;
  status: 'su' | 'ic' | 'du' | 'alr';
  message: string;
  subject?: {
    id: string;
    username: string;
    created_at: string;
    is_active: boolean;
  };
  token?: Token; // Session token
  error?: string | object;
}
```

**Behavior:**

- Validates username format and uniqueness
- Hashes password before storage
- Creates new subject record
- Generates session token
- Returns user information and token

**Example:**

```ts
const result = await engine.executeStep('username-password', 'register', {
  username: 'gamer123',
  password: 'securePassword123!',
  metadata: {
    displayName: 'Pro Gamer',
    favoriteGame: 'Space Adventure',
  },
});

if (result.success) {
  console.log('User registered:', result.subject.username);
  console.log('Session token:', result.token.accessToken);

  // Store token for authenticated requests
  localStorage.setItem('authToken', result.token.accessToken);
} else {
  console.log('Registration failed:', result.error);
}
```

### 2. Login

**Step name:** `login`  
**HTTP:** `POST /auth/login`  
**Auth:** Not required

Authenticate user with username and password.

**Input:**

```ts
{
  username: string; // User's username
  password: string; // User's password
}
```

**Output:**

```ts
{
  success: boolean;
  status: 'su' | 'ic' | 'nf' | 'aut';
  message: string;
  subject?: {
    id: string;
    username: string;
    last_login_at: string;
    is_active: boolean;
  };
  token?: Token; // Session token
  error?: string | object;
}
```

**Behavior:**

- Validates username and password
- Updates last login timestamp
- Generates new session token
- Returns user information and token

**Example:**

```ts
const result = await engine.executeStep('username-password', 'login', {
  username: 'gamer123',
  password: 'securePassword123!',
});

if (result.success) {
  console.log('Login successful:', result.subject.username);
  console.log('Last login:', result.subject.last_login_at);

  // Store token for authenticated requests
  localStorage.setItem('authToken', result.token.accessToken);
} else {
  console.log('Login failed:', result.error);
}
```

### 3. Change Password

**Step name:** `change-password`  
**HTTP:** `POST /auth/change-password`  
**Auth:** Required

Change the current user's password.

**Input:**

```ts
{
  token: Token; // Current session token
  currentPassword: string; // Current password for verification
  newPassword: string; // New password
}
```

**Output:**

```ts
{
  success: boolean;
  status: 'su' | 'ic' | 'aut' | 'nf';
  message: string;
  subject?: {
    id: string;
    username: string;
    updated_at: string;
  };
  token?: Token; // Updated session token
  error?: string | object;
}
```

**Behavior:**

- Verifies current password
- Validates new password requirements
- Updates password hash
- Generates new session token
- Invalidates old sessions (optional)

**Example:**

```ts
const result = await engine.executeStep(
  'username-password',
  'change-password',
  {
    token: userToken,
    currentPassword: 'oldPassword123',
    newPassword: 'newSecurePassword456!',
  },
);

if (result.success) {
  console.log('Password changed successfully');

  // Update stored token
  localStorage.setItem('authToken', result.token.accessToken);
} else {
  console.log('Password change failed:', result.error);
}
```

## Password Reset (Optional)

When `enableResetByUsername` is enabled, additional steps become available:

### Request Password Reset

```ts
// This would be a custom step you'd implement
const resetResult = await engine.executeStep(
  'username-password',
  'request-reset',
  {
    username: 'gamer123',
  },
);

if (resetResult.success) {
  console.log('Reset code sent:', resetResult.resetCode);
  // In a real app, you'd send this via SMS, email, or display it
}
```

### Reset Password with Code

```ts
// This would be a custom step you'd implement
const resetResult = await engine.executeStep(
  'username-password',
  'reset-password',
  {
    username: 'gamer123',
    resetCode: '123456',
    newPassword: 'brandNewPassword789!',
  },
);

if (resetResult.success) {
  console.log('Password reset successfully');
}
```

## Background Cleanup

The plugin registers cleanup tasks for expired reset codes:

```ts
engine.registerCleanupTask({
  name: 'expired-reset-codes',
  pluginName: 'username-password',
  intervalMs: 60 * 60 * 1000, // 1 hour
  enabled: true,
  runner: async (orm, config) => {
    // Clean up expired password reset codes
    const expiredCodes = await orm.deleteMany('password_reset_codes', {
      where: (b) => b('expires_at', '<', new Date()),
    });

    return {
      cleaned: expiredCodes.count,
      resetCodesDeleted: expiredCodes.count,
    };
  },
});
```

## Profile API

The plugin exposes user information in profiles:

```ts
const profile = await engine.getUnifiedProfile('user-123');

// profile.plugins['username-password']
{
  username: 'gamer123',
  created_at: '2025-01-15T10:30:00Z',
  last_login_at: '2025-01-15T14:20:00Z',
  is_active: true,
  has_reset_enabled: false,
  total_sessions: 3
}
```

## HTTP Adapter Integration

When using HTTP adapters, username steps are automatically exposed:

```ts
POST /auth/register         → username-password:register
POST /auth/login           → username-password:login
POST /auth/change-password → username-password:change-password (auth)
```

## Security Considerations

### 1. Username Validation

```ts
// Implement custom username validation
function validateUsername(username: string): boolean {
  // Only allow alphanumeric characters and underscores
  const usernameRegex = /^[a-zA-Z0-9_]{3,20}$/;

  // Check for reserved usernames
  const reservedUsernames = ['admin', 'root', 'system', 'api'];

  return (
    usernameRegex.test(username) &&
    !reservedUsernames.includes(username.toLowerCase())
  );
}
```

### 2. Password Requirements

```ts
// Implement strong password requirements
function validatePassword(password: string): boolean {
  // At least 8 characters, 1 uppercase, 1 lowercase, 1 number, 1 special character
  const passwordRegex =
    /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
  return passwordRegex.test(password);
}
```

### 3. Username Conflict Resolution

```ts
// Handle username conflicts gracefully
async function generateUniqueUsername(baseUsername: string): Promise<string> {
  let username = baseUsername;
  let counter = 1;

  while (await usernameExists(username)) {
    username = `${baseUsername}${counter}`;
    counter++;
  }

  return username;
}
```

## Complete Example: Gaming Platform

```ts
// 1. User registers for gaming platform
const registerResult = await engine.executeStep(
  'username-password',
  'register',
  {
    username: 'DragonSlayer99',
    password: 'GamingPassword123!',
    metadata: {
      displayName: 'Dragon Slayer',
      preferredGameMode: 'PvP',
      experienceLevel: 'Intermediate',
    },
  },
);

if (registerResult.success) {
  console.log('Welcome to the platform,', registerResult.subject.username);

  // Store session for immediate use
  const sessionToken = registerResult.token.accessToken;
  localStorage.setItem('gameToken', sessionToken);
}

// 2. User logs in later
const loginResult = await engine.executeStep('username-password', 'login', {
  username: 'DragonSlayer99',
  password: 'GamingPassword123!',
});

if (loginResult.success) {
  console.log('Welcome back,', loginResult.subject.username);

  // Update stored session
  localStorage.setItem('gameToken', loginResult.token.accessToken);

  // Load user's game data
  await loadGameProfile(loginResult.subject.id);
}

// 3. User changes password for security
const changeResult = await engine.executeStep(
  'username-password',
  'change-password',
  {
    token: sessionToken,
    currentPassword: 'GamingPassword123!',
    newPassword: 'UltraSecureGaming456!',
  },
);

if (changeResult.success) {
  console.log('Password updated successfully');

  // Update stored session with new token
  localStorage.setItem('gameToken', changeResult.token.accessToken);
}

// 4. User profile information
const profile = await engine.getUnifiedProfile(loginResult.subject.id);
console.log('User profile:', {
  username: profile.plugins['username-password'].username,
  joinDate: profile.plugins['username-password'].created_at,
  lastLogin: profile.plugins['username-password'].last_login_at,
});
```

## Use Cases

### Gaming Platform

```ts
usernamePasswordPlugin({
  sessionTtlSeconds: 86400, // 24 hour sessions for gaming
  enableRegistration: true,
  enableResetByUsername: true, // Allow password recovery
  resetCodeTtlMinutes: 10, // Quick reset codes
  cleanupIntervalMinutes: 30, // Frequent cleanup
});
```

### Forum Application

```ts
usernamePasswordPlugin({
  sessionTtlSeconds: 7200, // 2 hour sessions
  enableRegistration: true,
  enableResetByUsername: false, // No reset for simplicity
  cleanupIntervalMinutes: 60, // Standard cleanup
});
```

### Internal Tools

```ts
usernamePasswordPlugin({
  sessionTtlSeconds: 3600, // 1 hour sessions
  enableRegistration: false, // Admin-only registration
  enableResetByUsername: true, // Allow password reset
  resetCodeTtlMinutes: 5, // Short-lived reset codes
  cleanupIntervalMinutes: 15, // Frequent cleanup
});
```

## Next Steps

<Cards>
  <Card
    href="/docs/engine/plugins/session"
    title="Session Plugin"
    description="Add enhanced session management capabilities."
  />
  <Card
    href="/docs/engine/plugins/admin"
    title="Admin Plugin"
    description="Manage users through admin interface."
  />
  <Card
    href="/docs/engine/plugins/jwt"
    title="JWT Plugin"
    description="Use JWT tokens for stateless authentication."
  />
</Cards>
